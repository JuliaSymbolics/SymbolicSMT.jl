var documenterSearchIndex = {"docs":
[{"location":"manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"This section explains how to create and work with constraints in SymbolicSMT.jl.","category":"section"},{"location":"manual/constraints/#What-are-Constraints?","page":"Constraints","title":"What are Constraints?","text":"Constraints are boolean expressions that define the valid domain for your variables. They represent the conditions that must be satisfied in any solution to your problem.\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\n\n# These are constraints:\nx > 0           # x must be positive\ny >= -2         # y must be at least -2  \nx + y < 10      # sum must be less than 10\nx^2 + y^2 <= 1  # point must be inside unit circle","category":"section"},{"location":"manual/constraints/#Creating-Constraint-Sets","page":"Constraints","title":"Creating Constraint Sets","text":"Use the Constraints constructor to create a collection of constraints:\n\n# Single constraint\nconstraints1 = Constraints([x > 0])\n\n# Multiple constraints (all must be satisfied)\nconstraints2 = Constraints([\n    x > 0,\n    y >= 0, \n    x + y <= 10,\n    x - y >= -5\n])","category":"section"},{"location":"manual/constraints/#Types-of-Constraints","page":"Constraints","title":"Types of Constraints","text":"","category":"section"},{"location":"manual/constraints/#Linear-Constraints","page":"Constraints","title":"Linear Constraints","text":"Linear constraints involve variables with power 1:\n\n@variables x::Real y::Real z::Real\n\nlinear_constraints = Constraints([\n    x + 2*y - 3*z <= 5,\n    x - y >= 0,\n    2*x + y == 7\n])","category":"section"},{"location":"manual/constraints/#Quadratic-Constraints","page":"Constraints","title":"Quadratic Constraints","text":"Quadratic constraints involve squared terms:\n\nquadratic_constraints = Constraints([\n    x^2 + y^2 <= 1,    # Circle constraint\n    x^2 - y >= 0,      # Parabola constraint\n    (x - 1)^2 + (y - 2)^2 <= 4  # Circle centered at (1,2)\n])","category":"section"},{"location":"manual/constraints/#Boolean-Constraints","page":"Constraints","title":"Boolean Constraints","text":"Boolean constraints involve logical variables and operations:\n\n@variables p::Bool q::Bool r::Bool\n\nboolean_constraints = Constraints([\n    p,              # p must be true\n    !q | r,         # either q is false or r is true\n    p & (q | !r)    # p and (q or not r)\n])","category":"section"},{"location":"manual/constraints/#Mixed-Constraints","page":"Constraints","title":"Mixed Constraints","text":"Combine different types of variables and constraints:\n\n@variables x::Real n::Integer valid::Bool\n\nmixed_constraints = Constraints([\n    x >= 0,                    # Real constraint\n    n >= 1,                    # Integer constraint\n    valid | (x < n),           # Boolean + mixed constraint\n    x^2 + n <= 10              # Nonlinear mixed constraint\n])","category":"section"},{"location":"manual/constraints/#Constraint-Evaluation","page":"Constraints","title":"Constraint Evaluation","text":"","category":"section"},{"location":"manual/constraints/#Empty-Constraint-Sets","page":"Constraints","title":"Empty Constraint Sets","text":"Empty constraint sets are always satisfiable:\n\nempty_constraints = Constraints([])\nissatisfiable(x > 100, empty_constraints)  # true - no restrictions","category":"section"},{"location":"manual/constraints/#Contradictory-Constraints","page":"Constraints","title":"Contradictory Constraints","text":"Some constraint sets have no solutions:\n\nimpossible = Constraints([x > 5, x < 3])\nissatisfiable(true, impossible)  # false - constraint set is unsatisfiable","category":"section"},{"location":"manual/constraints/#Redundant-Constraints","page":"Constraints","title":"Redundant Constraints","text":"Some constraints may be implied by others:\n\n# The second constraint is redundant\nredundant = Constraints([x > 5, x > 3])  # x > 3 is implied by x > 5","category":"section"},{"location":"manual/constraints/#Working-with-Constraint-Objects","page":"Constraints","title":"Working with Constraint Objects","text":"","category":"section"},{"location":"manual/constraints/#Inspecting-Constraints","page":"Constraints","title":"Inspecting Constraints","text":"You can examine the constraints in a Constraints object:\n\ncs = Constraints([x > 0, y <= 5])\nprintln(cs)  # Shows: Constraints: x > 0 ' y <= 5\n\n# Access the constraint expressions\ncs.constraints  # Vector of original expressions","category":"section"},{"location":"manual/constraints/#Constraint-Context","page":"Constraints","title":"Constraint Context","text":"Each Constraints object maintains its own Z3 solver context:\n\ncs = Constraints([x > 0])\n# cs.solver contains the Z3 solver\n# cs.context contains the Z3 context","category":"section"},{"location":"manual/constraints/#Advanced-Constraint-Patterns","page":"Constraints","title":"Advanced Constraint Patterns","text":"","category":"section"},{"location":"manual/constraints/#Conditional-Constraints","page":"Constraints","title":"Conditional Constraints","text":"Use boolean variables to create conditional constraints:\n\n@variables x::Real active::Bool\n\nconditional = Constraints([\n    active => (x > 0),  # If active, then x > 0\n    !active => (x <= 0) # If not active, then x <= 0\n])","category":"section"},{"location":"manual/constraints/#Range-Constraints","page":"Constraints","title":"Range Constraints","text":"Define variables within specific ranges:\n\n@variables angle::Real\n\n# Angle between 0 and 2*pi\nangle_constraints = Constraints([\n    angle >= 0,\n    angle <= 2*pi\n])","category":"section"},{"location":"manual/constraints/#Geometric-Constraints","page":"Constraints","title":"Geometric Constraints","text":"Model geometric relationships:\n\n@variables x1::Real y1::Real x2::Real y2::Real\n\n# Two points on the unit circle\nunit_circle = Constraints([\n    x1^2 + y1^2 == 1,\n    x2^2 + y2^2 == 1\n])\n\n# Distance constraint\ndistance_constraint = Constraints([\n    (x1 - x2)^2 + (y1 - y2)^2 <= 1  # Points within distance 1\n])","category":"section"},{"location":"manual/constraints/#Tips-for-Effective-Constraint-Design","page":"Constraints","title":"Tips for Effective Constraint Design","text":"","category":"section"},{"location":"manual/constraints/#1.-Start-Simple","page":"Constraints","title":"1. Start Simple","text":"Begin with simple constraints and add complexity gradually:\n\n# Start with basic bounds\nbasic = Constraints([x >= 0, y >= 0])\n\n# Add more specific constraints\nrefined = Constraints([x >= 0, y >= 0, x + y <= 10, x - y >= -2])","category":"section"},{"location":"manual/constraints/#2.-Use-Appropriate-Types","page":"Constraints","title":"2. Use Appropriate Types","text":"Choose variable types that match your problem:\n\n# For continuous optimization\n@variables position::Real velocity::Real\n\n# For counting problems  \n@variables count::Integer items::Integer\n\n# For logical conditions\n@variables enabled::Bool valid::Bool","category":"section"},{"location":"manual/constraints/#3.-Structure-Boolean-Logic","page":"Constraints","title":"3. Structure Boolean Logic","text":"Make boolean expressions as simple as possible:\n\n# Prefer simple forms\nsimple = Constraints([p, !q])\n\n# Over complex nested expressions\ncomplex = Constraints([((p & q) | (!p & !q)) & (p | q)])","category":"section"},{"location":"manual/constraints/#4.-Check-Constraint-Satisfiability","page":"Constraints","title":"4. Check Constraint Satisfiability","text":"Always verify your constraint set has solutions:\n\ncs = Constraints([x > 5, x < 3])  # Oops! No solutions\nissatisfiable(true, cs)  # false - indicates problem with constraints","category":"section"},{"location":"manual/constraints/#Common-Patterns","page":"Constraints","title":"Common Patterns","text":"","category":"section"},{"location":"manual/constraints/#Optimization-Bounds","page":"Constraints","title":"Optimization Bounds","text":"@variables x::Real y::Real\n\nbounds = Constraints([\n    x >= -10, x <= 10,\n    y >= -10, y <= 10\n])","category":"section"},{"location":"manual/constraints/#Non-negativity","page":"Constraints","title":"Non-negativity","text":"non_negative = Constraints([x >= 0, y >= 0, z >= 0])","category":"section"},{"location":"manual/constraints/#Normalization","page":"Constraints","title":"Normalization","text":"# Unit vector constraint\nunit_vector = Constraints([x^2 + y^2 + z^2 == 1])","category":"section"},{"location":"manual/constraints/#Mutual-Exclusion","page":"Constraints","title":"Mutual Exclusion","text":"@variables option1::Bool option2::Bool option3::Bool\n\n# Exactly one option must be true\nexactly_one = Constraints([\n    option1 | option2 | option3,           # At least one\n    !(option1 & option2),                  # Not both 1 and 2\n    !(option1 & option3),                  # Not both 1 and 3\n    !(option2 & option3)                   # Not both 2 and 3\n])","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for SymbolicSMT.jl.","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Satisfiability-and-Provability","page":"API Reference","title":"Satisfiability and Provability","text":"","category":"section"},{"location":"api/#Expression-Resolution","page":"API Reference","title":"Expression Resolution","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#SymbolicSMT.Constraints","page":"API Reference","title":"SymbolicSMT.Constraints","text":"Constraints(constraints::Vector, solvertype=\"QF_NRA\")\n\nA collection of boolean constraints with an associated Z3 solver.\n\nThis type wraps a vector of SymbolicUtils boolean expressions and manages the corresponding Z3 solver context. Constraints are automatically converted to Z3 format and added to the solver upon construction.\n\nArguments\n\nconstraints::Vector: Vector of boolean SymbolicUtils expressions\nsolvertype::String=\"QF_NRA\": Z3 solver type to use\n\nFields\n\nconstraints::Vector: Original SymbolicUtils expressions\nsolver::Z3.Solver: Z3 solver instance with constraints added\ncontext::Z3.Context: Z3 context associated with the solver\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\n# Single constraint\nc1 = Constraints([x > 0])\n\n# Multiple constraints\nc2 = Constraints([x > 0, y > 0, x + y < 10])\n\n# Specify solver type\nc3 = Constraints([x > 0], \"QF_LRA\")\n\n\n\n\n\n","category":"type"},{"location":"api/#SymbolicSMT.issatisfiable","page":"API Reference","title":"SymbolicSMT.issatisfiable","text":"issatisfiable(expr, constraints::Constraints)\n\nCheck whether the given expression can be satisfied under the constraints.\n\nDetermines if there exists at least one assignment of variables that makes both the constraints and the expression true.\n\nArguments\n\nexpr: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\nconstraints = Constraints([x > 0, y > 0])\n\n# Can x be negative?\nissatisfiable(x < 0, constraints)  # false\n\n# Can x + y be greater than 1?\nissatisfiable(x + y > 1, constraints)  # true\n\n\n\n\n\nissatisfiable(expr::Bool, ::Constraints)\n\nHandle satisfiability checking for boolean literals.\n\nBoolean literals are trivially satisfiable based on their truth value.\n\nArguments\n\nexpr::Bool: Boolean literal (true or false)\n::Constraints: Constraints (ignored for boolean literals)\n\nReturns\n\nThe boolean value itself.\n\n\n\n\n\nissatisfiable(expr::Num, constraints::Constraints)\n\nCheck satisfiability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Check with Symbolics.jl Num expressions\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicSMT.isprovable","page":"API Reference","title":"SymbolicSMT.isprovable","text":"isprovable(expr, constraints::Constraints)\n\nCheck whether the given expression is provable (always true) under the constraints.\n\nAn expression is provable if it is true for all assignments of variables that satisfy the constraints. This is equivalent to checking that the negation of the expression is unsatisfiable under the constraints.\n\nArguments\n\nexpr: Boolean expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provable (always true) given the constraints\nfalse: The expression is not provable given the constraints\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Is x + y always non-negative?\nisprovable(x + y >= 0, constraints)  # true\n\n# Is x always greater than y?\nisprovable(x > y, constraints)  # false\n\n\n\n\n\nisprovable(expr::Num, constraints::Constraints)\n\nCheck provability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provably true under the constraints\nfalse: The expression can be false under the constraints\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Check provability with Symbolics.jl\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicSMT.resolve","page":"API Reference","title":"SymbolicSMT.resolve","text":"resolve(expr, constraints::Constraints)\n\nAttempt to resolve an expression to a boolean constant using the constraints.\n\nTries to determine if the expression is provably true or provably false under the given constraints. If neither can be proven, returns the original expression unchanged.\n\nArguments\n\nexpr: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nexpr: The original expression if it cannot be resolved\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real\n\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)   # true (provable)\nresolve(x < 0, constraints)   # false (provable negation)\nresolve(x > 10, constraints)  # x > 10 (cannot resolve)\n\n\n\n\n\nresolve(expr::Num, constraints::Constraints)\n\nResolve a Symbolics.jl Num expression to a boolean constant if possible.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, delegates to the core implementation, and wraps boolean results back to Num if needed.\n\nArguments\n\nexpr::Num: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nNum: The wrapped original expression if it cannot be resolved\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)\n\n\n\n\n\n","category":"function"},{"location":"manual/basics/#Basics","page":"Basics","title":"Basics","text":"This section covers the fundamental concepts and usage patterns in SymbolicSMT.jl.","category":"section"},{"location":"manual/basics/#Overview","page":"Basics","title":"Overview","text":"SymbolicSMT.jl bridges the gap between symbolic computation and satisfiability solving. It allows you to:\n\nDefine symbolic constraints on real, integer, and boolean variables\nCheck if logical expressions are satisfiable under those constraints  \nProve or disprove symbolic statements\nSimplify expressions using constraint-based reasoning","category":"section"},{"location":"manual/basics/#The-SymbolicSMT-Workflow","page":"Basics","title":"The SymbolicSMT Workflow","text":"The typical workflow involves three main steps:\n\nCreate symbolic variables using Symbolics.jl or SymbolicUtils.jl\nDefine constraints that bound the problem domain\nQuery satisfiability or provability of expressions\n\nusing Symbolics, SymbolicSMT\n\n# Step 1: Create variables\n@variables x::Real y::Real\n\n# Step 2: Define constraints\nconstraints = Constraints([x >= 0, y >= 0, x + y <= 10])\n\n# Step 3: Query the system\nissatisfiable(x + y > 5, constraints)  # true\nisprovable(x >= 0, constraints)        # true","category":"section"},{"location":"manual/basics/#Types-of-Variables","page":"Basics","title":"Types of Variables","text":"SymbolicSMT.jl supports different types of symbolic variables:","category":"section"},{"location":"manual/basics/#Real-Variables","page":"Basics","title":"Real Variables","text":"Real variables represent continuous numeric values:\n\n@variables x::Real y::Real temperature::Real\n\nThese can be used in arithmetic expressions and inequality constraints.","category":"section"},{"location":"manual/basics/#Integer-Variables","page":"Basics","title":"Integer Variables","text":"Integer variables represent discrete numeric values:\n\n@variables n::Integer count::Integer age::Integer\n\nInteger variables support the same operations as real variables but are constrained to integer solutions.","category":"section"},{"location":"manual/basics/#Boolean-Variables","page":"Basics","title":"Boolean Variables","text":"Boolean variables represent logical values:\n\n@variables p::Bool flag::Bool condition::Bool\n\nBoolean variables are useful for encoding logical relationships and conditional constraints.","category":"section"},{"location":"manual/basics/#Supported-Operations","page":"Basics","title":"Supported Operations","text":"","category":"section"},{"location":"manual/basics/#Arithmetic-Operations","page":"Basics","title":"Arithmetic Operations","text":"Addition: x + y, x + 5\nSubtraction: x - y, x - 3  \nMultiplication: x * y, 2 * x\nPowers: x^2, x^n\nUnary minus: -x","category":"section"},{"location":"manual/basics/#Comparison-Operations","page":"Basics","title":"Comparison Operations","text":"Equal: x == y\nGreater than: x > y\nGreater than or equal: x >= y  \nLess than: x < y\nLess than or equal: x <= y","category":"section"},{"location":"manual/basics/#Logical-Operations","page":"Basics","title":"Logical Operations","text":"AND: p & q\nOR: p | q\nNOT: !p","category":"section"},{"location":"manual/basics/#Type-System-Integration","page":"Basics","title":"Type System Integration","text":"SymbolicSMT.jl handles the conversion between Symbolics/SymbolicUtils types and Z3 types:","category":"section"},{"location":"manual/basics/#Supported-Type-Mappings","page":"Basics","title":"Supported Type Mappings","text":"Real -> Z3 Int (current implementation treats reals as integers)\nInteger -> Z3 Int\nBool -> Z3 Bool","category":"section"},{"location":"manual/basics/#Automatic-Conversion","page":"Basics","title":"Automatic Conversion","text":"The conversion happens automatically when creating constraints:\n\n@variables x::Real p::Bool\nconstraints = Constraints([x > 0, p])  # Automatic type conversion","category":"section"},{"location":"manual/basics/#Frontend-Interfaces","page":"Basics","title":"Frontend Interfaces","text":"","category":"section"},{"location":"manual/basics/#Symbolics.jl-Interface-(Recommended)","page":"Basics","title":"Symbolics.jl Interface (Recommended)","text":"The modern, user-friendly interface using @variables:\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)","category":"section"},{"location":"manual/basics/#SymbolicUtils.jl-Interface","page":"Basics","title":"SymbolicUtils.jl Interface","text":"The lower-level interface for advanced users:\n\nusing SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])  \nissatisfiable(x + y > 1, constraints)\n\nBoth interfaces can be mixed in the same code.","category":"section"},{"location":"manual/basics/#Performance-Considerations","page":"Basics","title":"Performance Considerations","text":"","category":"section"},{"location":"manual/basics/#Solver-Complexity","page":"Basics","title":"Solver Complexity","text":"Different constraint types have different computational complexity:\n\nLinear arithmetic: Generally efficient\nNonlinear arithmetic: More expensive\nBoolean satisfiability: Depends on structure\nMixed integer: Can be challenging","category":"section"},{"location":"manual/basics/#Best-Practices","page":"Basics","title":"Best Practices","text":"Keep constraints simple when possible\nUse appropriate variable types (prefer Real over Integer when exact integers aren't required)\nBatch constraint creation rather than creating many small constraint sets\nStructure boolean expressions to be as simple as possible","category":"section"},{"location":"manual/basics/#Error-Handling","page":"Basics","title":"Error Handling","text":"SymbolicSMT.jl provides informative error messages when expressions cannot be converted:\n\n# This will show what failed to convert if there are unsupported operations\ntry\n    constraints = Constraints([some_unsupported_expr])\ncatch e\n    println(e)  # Detailed error message\nend","category":"section"},{"location":"manual/basics/#Understanding-Results","page":"Basics","title":"Understanding Results","text":"","category":"section"},{"location":"manual/basics/#Satisfiability-Results","page":"Basics","title":"Satisfiability Results","text":"issatisfiable returns:\n\ntrue: There exists at least one solution\nfalse: No solution exists  \nnothing: The solver cannot determine (rare)","category":"section"},{"location":"manual/basics/#Provability-Results","page":"Basics","title":"Provability Results","text":"isprovable returns:\n\ntrue: The statement is always true under the constraints\nfalse: The statement can be false under the constraints","category":"section"},{"location":"manual/basics/#Resolution-Results","page":"Basics","title":"Resolution Results","text":"resolve returns:\n\ntrue: The expression is provably true\nfalse: The expression is provably false\nOriginal expression (as Num or Symbolic): Cannot be determined","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial will walk you through the basics of using SymbolicSMT.jl to solve symbolic constraint problems.","category":"section"},{"location":"getting_started/#Installation-and-Setup","page":"Getting Started","title":"Installation and Setup","text":"First, install the required packages:\n\nusing Pkg\nPkg.add([\"SymbolicSMT\", \"Symbolics\"])\n\nThen load the packages:\n\nusing Symbolics, SymbolicSMT","category":"section"},{"location":"getting_started/#Creating-Symbolic-Variables-with-Symbolics.jl","page":"Getting Started","title":"Creating Symbolic Variables with Symbolics.jl","text":"SymbolicSMT.jl works seamlessly with Symbolics.jl @variables and Num types:\n\n@variables x::Real y::Real z::Integer p::Bool\n\nThis creates symbolic variables: x and y as real numbers, z as an integer, and p as a boolean.","category":"section"},{"location":"getting_started/#Defining-Constraints","page":"Getting Started","title":"Defining Constraints","text":"Constraints are collections of boolean expressions that must be satisfied. Create constraints using the Constraints constructor:\n\n# Simple constraints with Symbolics.jl variables\nconstraints = Constraints([\n    x > 0,      # x must be positive\n    y >= -2,    # y must be at least -2\n    x + y < 10  # sum must be less than 10\n])","category":"section"},{"location":"getting_started/#Checking-Satisfiability","page":"Getting Started","title":"Checking Satisfiability","text":"Use issatisfiable to check if an expression can be true given the constraints:\n\n# Can x be greater than 5?\nissatisfiable(x > 5, constraints)  # true - possible\n\n# Can x be negative?\nissatisfiable(x < 0, constraints)  # false - conflicts with x > 0\n\n# Can x + y equal 15?\nissatisfiable(x + y == 15, constraints)  # false - conflicts with x + y < 10","category":"section"},{"location":"getting_started/#Checking-Provability","page":"Getting Started","title":"Checking Provability","text":"Use isprovable to check if an expression is always true given the constraints:\n\n# Is x always positive?\nisprovable(x > 0, constraints)     # true - follows from constraints\n\n# Is x always greater than y?\nisprovable(x > y, constraints)     # false - not necessarily true","category":"section"},{"location":"getting_started/#Expression-Resolution","page":"Getting Started","title":"Expression Resolution","text":"The resolve function attempts to simplify expressions to boolean constants:\n\n@variables t::Real\ntime_constraints = Constraints([t >= 0, t <= 24])  # Time in hours\n\n# These resolve to constants\nresolve(t >= 0, time_constraints)   # true (always true)\nresolve(t < 0, time_constraints)    # false (never true)\n\n# This cannot be resolved (returns original Num expression)\nresolve(t > 12, time_constraints)   # t > 12 (unchanged)","category":"section"},{"location":"getting_started/#Working-with-Different-Variable-Types","page":"Getting Started","title":"Working with Different Variable Types","text":"","category":"section"},{"location":"getting_started/#Real-Variables","page":"Getting Started","title":"Real Variables","text":"@variables x::Real y::Real temperature::Real\n\nconstraints = Constraints([x >= 0, y >= 0, temperature > 273.15])\nissatisfiable(x + y > temperature, constraints)","category":"section"},{"location":"getting_started/#Integer-Variables","page":"Getting Started","title":"Integer Variables","text":"@variables n::Integer count::Integer age::Integer\n\nconstraints = Constraints([n >= 1, count <= 100, age >= 0])\nisprovable(n > 0, constraints)  # true","category":"section"},{"location":"getting_started/#Boolean-Variables","page":"Getting Started","title":"Boolean Variables","text":"@variables valid::Bool active::Bool\n\nconstraints = Constraints([valid, !active])  # valid is true, active is false\nisprovable(valid | active, constraints)  # true","category":"section"},{"location":"getting_started/#Complex-Expressions","page":"Getting Started","title":"Complex Expressions","text":"SymbolicSMT.jl supports complex arithmetic and boolean expressions:\n\n@variables a::Real b::Real\n\n# Quadratic constraints\nquadratic_constraints = Constraints([\n    a^2 + b^2 <= 1,  # Inside unit circle\n    a >= 0           # First quadrant\n])\n\n# Check complex expressions\nissatisfiable(a * b > 0.1, quadratic_constraints)\nisprovable(a >= 0, quadratic_constraints)  # true","category":"section"},{"location":"getting_started/#Return-Values","page":"Getting Started","title":"Return Values","text":"Understanding the return values:\n\ntrue: The expression is satisfiable/provable\nfalse: The expression is unsatisfiable/not provable  \nnothing: The solver cannot determine the result (rare)\n\nFor resolve, boolean results are returned as Bool, while unresolved expressions are returned as Num.","category":"section"},{"location":"getting_started/#Alternative-Interface:-SymbolicUtils.jl","page":"Getting Started","title":"Alternative Interface: SymbolicUtils.jl","text":"You can also use the lower-level SymbolicUtils.jl interface directly:\n\nusing SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Read the Manual for deeper understanding of concepts\nCheck out Tutorials for more complex examples\nBrowse the API Reference for complete function documentation","category":"section"},{"location":"tutorials/basic_examples/#Basic-Examples","page":"Basic Examples","title":"Basic Examples","text":"This tutorial provides practical examples of using SymbolicSMT.jl for various types of problems.","category":"section"},{"location":"tutorials/basic_examples/#Example-1:-Planning-and-Scheduling","page":"Basic Examples","title":"Example 1: Planning and Scheduling","text":"Let's solve a simple resource allocation problem:\n\nusing Symbolics, SymbolicSMT\n\n# Define variables: time allocated to each task (in hours)\n@variables task1::Real task2::Real task3::Real\n\n# Constraints: budget and minimum requirements\nconstraints = Constraints([\n    task1 >= 2,           # Task 1 needs at least 2 hours\n    task2 >= 1,           # Task 2 needs at least 1 hour  \n    task3 >= 3,           # Task 3 needs at least 3 hours\n    task1 + task2 + task3 <= 10  # Total budget is 10 hours\n])\n\n# Questions we can ask:\nissatisfiable(task1 + task2 + task3 == 10, constraints)  # true - can use full budget\nissatisfiable(task1 > 5, constraints)                    # true - task1 can be > 5\nissatisfiable(task1 > 6, constraints)                    # false - would exceed budget","category":"section"},{"location":"tutorials/basic_examples/#Example-2:-Geometric-Reasoning","page":"Basic Examples","title":"Example 2: Geometric Reasoning","text":"Solve problems involving geometric shapes and relationships:\n\n@variables x::Real y::Real\n\n# Point inside unit circle\ninside_circle = Constraints([x^2 + y^2 <= 1])\n\n# Point in first quadrant\nfirst_quadrant = Constraints([x >= 0, y >= 0])\n\n# Combined constraints\nconstraints = Constraints([x^2 + y^2 <= 1, x >= 0, y >= 0])\n\n# Geometric questions:\nissatisfiable(x > 0.5 & y > 0.5, constraints)           # Check if corner point exists\nisprovable(x >= 0, constraints)                         # true - always in first quadrant  \nissatisfiable(x^2 + y^2 > 0.9, constraints)            # true - can be near boundary","category":"section"},{"location":"tutorials/basic_examples/#Example-3:-Logic-Puzzles","page":"Basic Examples","title":"Example 3: Logic Puzzles","text":"Solve propositional logic problems:\n\n@variables alice_tall::Bool bob_tall::Bool charlie_tall::Bool\n\n# Logic puzzle constraints:\n# 1. At least one person is tall\n# 2. If Alice is tall, then Bob is not tall\n# 3. Charlie is tall if and only if exactly one of Alice/Bob is tall\n\npuzzle_constraints = Constraints([\n    alice_tall | bob_tall | charlie_tall,              # At least one tall\n    !alice_tall | !bob_tall,                           # Alice tall => Bob not tall\n    charlie_tall == ((alice_tall & !bob_tall) | (!alice_tall & bob_tall))  # Charlie iff exactly one\n])\n\n# Solution questions:\nissatisfiable(alice_tall & !bob_tall & charlie_tall, puzzle_constraints)  # Check specific solution\nisprovable(charlie_tall => (alice_tall | bob_tall), puzzle_constraints)   # Logical implication","category":"section"},{"location":"tutorials/basic_examples/#Example-4:-System-Configuration","page":"Basic Examples","title":"Example 4: System Configuration","text":"Model system configuration constraints:\n\n@variables memory::Integer cores::Integer storage::Integer\n\n# System requirements\nsystem_constraints = Constraints([\n    memory >= 4,           # At least 4GB RAM\n    cores >= 2,            # At least 2 CPU cores\n    storage >= 100,        # At least 100GB storage\n    memory * cores <= 32,  # Memory-core product limit\n    storage <= 1000        # Storage upper limit\n])\n\n# Configuration questions:\nissatisfiable(memory == 8 & cores == 4, system_constraints)      # Valid config?\nisprovable(memory + cores >= 6, system_constraints)              # Always true?\nissatisfiable(memory > 16 & cores > 4, system_constraints)       # High-end possible?","category":"section"},{"location":"tutorials/basic_examples/#Example-5:-Financial-Modeling","page":"Basic Examples","title":"Example 5: Financial Modeling","text":"Model financial constraints and optimization:\n\n@variables stocks::Real bonds::Real cash::Real\n\n# Portfolio constraints\nportfolio_constraints = Constraints([\n    stocks >= 0, bonds >= 0, cash >= 0,    # No short selling\n    stocks + bonds + cash == 100000,       # Total portfolio value\n    stocks <= 60000,                       # Max 60% in stocks\n    cash >= 10000                          # Minimum cash reserve\n])\n\n# Investment questions:\nissatisfiable(stocks > 50000, portfolio_constraints)              # Can we have >50% stocks?\nisprovable(bonds + cash >= 40000, portfolio_constraints)          # Always have 40%+ in bonds/cash?\nresolve(cash >= 10000, portfolio_constraints)                     # true - always satisfied","category":"section"},{"location":"tutorials/basic_examples/#Example-6:-Process-Control","page":"Basic Examples","title":"Example 6: Process Control","text":"Model control system constraints:\n\n@variables temperature::Real pressure::Real flow_rate::Real\n\n# Safe operating constraints\nsafety_constraints = Constraints([\n    temperature >= 20, temperature <= 80,     # Temperature range\n    pressure >= 1, pressure <= 5,             # Pressure range  \n    flow_rate >= 0, flow_rate <= 100,         # Flow rate range\n    temperature * pressure <= 300,            # Safety interlock\n    flow_rate <= 2 * pressure                 # Flow depends on pressure\n])\n\n# Safety verification:\nisprovable(temperature <= 80, safety_constraints)                 # Always safe temp?\nissatisfiable(pressure > 4 & flow_rate > 8, safety_constraints)  # High pressure/flow possible?\nresolve(temperature > 60, safety_constraints)                     # Can we run hot?","category":"section"},{"location":"tutorials/basic_examples/#Example-7:-Network-Topology","page":"Basic Examples","title":"Example 7: Network Topology","text":"Model network connectivity constraints:\n\n@variables node1_active::Bool node2_active::Bool node3_active::Bool\n@variables link12::Bool link13::Bool link23::Bool\n\n# Network constraints\nnetwork_constraints = Constraints([\n    # Links exist only if both nodes are active\n    link12 => (node1_active & node2_active),\n    link13 => (node1_active & node3_active), \n    link23 => (node2_active & node3_active),\n    \n    # At least one node must be active\n    node1_active | node2_active | node3_active,\n    \n    # Network must be connected (at least one link if multiple nodes)\n    (node1_active & node2_active) => link12,\n    (node1_active & node3_active) => link13,\n    (node2_active & node3_active) => link23\n])\n\n# Network analysis:\nissatisfiable(node1_active & node2_active & !link12, network_constraints)  # false\nisprovable(link12 => (node1_active & node2_active), network_constraints)   # true","category":"section"},{"location":"tutorials/basic_examples/#Example-8:-Hybrid-Systems","page":"Basic Examples","title":"Example 8: Hybrid Systems","text":"Combine continuous and discrete variables:\n\n@variables position::Real velocity::Real\n@variables gear::Integer braking::Bool\n\n# Vehicle dynamics constraints\nvehicle_constraints = Constraints([\n    position >= 0,                    # Position bounds\n    velocity >= 0, velocity <= 120,   # Speed limits\n    gear >= 1, gear <= 5,            # Gear range\n    \n    # Gear-speed relationship\n    (gear == 1) => (velocity <= 30),\n    (gear == 2) => (velocity <= 50),\n    (gear == 3) => (velocity <= 70),\n    \n    # Braking physics\n    braking => (velocity <= 60)       # Can't brake effectively at high speed\n])\n\n# Driving scenario analysis:\nissatisfiable(velocity > 80 & gear <= 3, vehicle_constraints)     # Possible?\nisprovable(braking => (gear <= 3), vehicle_constraints)          # Braking implies low gear?","category":"section"},{"location":"tutorials/basic_examples/#Tips-for-Effective-SAT-Solving","page":"Basic Examples","title":"Tips for Effective SAT Solving","text":"","category":"section"},{"location":"tutorials/basic_examples/#1.-Structure-Your-Queries","page":"Basic Examples","title":"1. Structure Your Queries","text":"Ask specific, well-defined questions:\n\n# Good: Specific question\nissatisfiable(x > 5 & y < 3, constraints)\n\n# Better: Break down complex queries\nissatisfiable(x > 5, constraints) && issatisfiable(y < 3, constraints)","category":"section"},{"location":"tutorials/basic_examples/#2.-Use-Appropriate-Granularity","page":"Basic Examples","title":"2. Use Appropriate Granularity","text":"Choose the right level of detail:\n\n# For rough feasibility\nissatisfiable(x > 0, constraints)\n\n# For precise analysis  \nissatisfiable(x >= 2.5 & x <= 2.6, constraints)","category":"section"},{"location":"tutorials/basic_examples/#3.-Leverage-Provability","page":"Basic Examples","title":"3. Leverage Provability","text":"Use provability to verify invariants:\n\n# Safety verification\nisprovable(temperature <= max_temp, safety_constraints)  # Always safe?\n\n# Optimization verification\nisprovable(profit >= 0, business_constraints)            # Always profitable?","category":"section"},{"location":"tutorials/basic_examples/#4.-Combine-Multiple-Queries","page":"Basic Examples","title":"4. Combine Multiple Queries","text":"Build complex analysis from simple queries:\n\n# Check if exactly one solution exists\nhas_solution = issatisfiable(expr, constraints)\nunique_solution = has_solution && isprovable(expr, constraints)","category":"section"},{"location":"tutorials/basic_examples/#Common-Patterns","page":"Basic Examples","title":"Common Patterns","text":"","category":"section"},{"location":"tutorials/basic_examples/#Feasibility-Checking","page":"Basic Examples","title":"Feasibility Checking","text":"issatisfiable(candidate_solution, constraints)","category":"section"},{"location":"tutorials/basic_examples/#Invariant-Verification","page":"Basic Examples","title":"Invariant Verification","text":"isprovable(safety_property, constraints)","category":"section"},{"location":"tutorials/basic_examples/#Bounds-Analysis","page":"Basic Examples","title":"Bounds Analysis","text":"issatisfiable(variable > upper_bound, constraints)  # Can exceed bound?\nisprovable(variable >= lower_bound, constraints)    # Always above bound?","category":"section"},{"location":"tutorials/basic_examples/#Configuration-Validation","page":"Basic Examples","title":"Configuration Validation","text":"issatisfiable(configuration_expr, system_constraints)","category":"section"},{"location":"manual/sat_solving/#SAT-Solving","page":"SAT Solving","title":"SAT Solving","text":"This section explains the satisfiability solving capabilities of SymbolicSMT.jl.","category":"section"},{"location":"manual/sat_solving/#Satisfiability-vs-Provability","page":"SAT Solving","title":"Satisfiability vs Provability","text":"SymbolicSMT.jl provides two main types of queries:","category":"section"},{"location":"manual/sat_solving/#Satisfiability-(issatisfiable)","page":"SAT Solving","title":"Satisfiability (issatisfiable)","text":"Question: \"Can this expression be true given the constraints?\"\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Can x be greater than 10?\nissatisfiable(x > 10, constraints)  # true - yes, it's possible","category":"section"},{"location":"manual/sat_solving/#Provability-(isprovable)","page":"SAT Solving","title":"Provability (isprovable)","text":"Question: \"Is this expression always true given the constraints?\"\n\n# Is x always positive?\nisprovable(x > 0, constraints)  # true - yes, always true\n\n# Is x always greater than y?\nisprovable(x > y, constraints)  # false - not necessarily true","category":"section"},{"location":"manual/sat_solving/#Understanding-Return-Values","page":"SAT Solving","title":"Understanding Return Values","text":"","category":"section"},{"location":"manual/sat_solving/#Three-Valued-Logic","page":"SAT Solving","title":"Three-Valued Logic","text":"Both functions can return three possible values:\n\ntrue: Yes (satisfiable/provable)\nfalse: No (unsatisfiable/not provable)\nnothing: Unknown (solver timeout or undecidable)\n\nresult = issatisfiable(complex_expression, constraints)\n\nif result === true\n    println(\"Satisfiable!\")\nelseif result === false\n    println(\"Unsatisfiable!\")\nelse  # result === nothing\n    println(\"Solver couldn't determine\")\nend","category":"section"},{"location":"manual/sat_solving/#Practical-Interpretation","page":"SAT Solving","title":"Practical Interpretation","text":"","category":"section"},{"location":"manual/sat_solving/#For-issatisfiable:","page":"SAT Solving","title":"For issatisfiable:","text":"true: There exists at least one solution\nfalse: No solution exists\nnothing: Solver cannot determine (rare)","category":"section"},{"location":"manual/sat_solving/#For-isprovable:","page":"SAT Solving","title":"For isprovable:","text":"true: Statement is always true (tautology under constraints)\nfalse: Statement can be false (not a tautology)\nnothing: Solver cannot determine (rare)","category":"section"},{"location":"manual/sat_solving/#Resolution-with-resolve","page":"SAT Solving","title":"Resolution with resolve","text":"The resolve function combines both operations to simplify expressions:\n\n@variables t::Real\ntime_constraints = Constraints([t >= 0, t <= 24])\n\n# Expressions that resolve to constants\nresolve(t >= 0, time_constraints)   # true (always true)\nresolve(t < 0, time_constraints)    # false (never true)\nresolve(t > 30, time_constraints)   # false (impossible)\n\n# Expressions that cannot be resolved\nresolve(t > 12, time_constraints)   # t > 12 (unchanged)","category":"section"},{"location":"manual/sat_solving/#Practical-Examples","page":"SAT Solving","title":"Practical Examples","text":"","category":"section"},{"location":"manual/sat_solving/#Example-1:-Geometric-Reasoning","page":"SAT Solving","title":"Example 1: Geometric Reasoning","text":"@variables x::Real y::Real\n\n# Points inside unit circle\nunit_circle = Constraints([x^2 + y^2 <= 1])\n\n# Can a point be outside the circle?\nissatisfiable(x^2 + y^2 > 1, unit_circle)  # false\n\n# Are all points within distance 1 of origin?\nisprovable(x^2 + y^2 <= 1, unit_circle)    # true","category":"section"},{"location":"manual/sat_solving/#Example-2:-Logical-Reasoning","page":"SAT Solving","title":"Example 2: Logical Reasoning","text":"@variables p::Bool q::Bool r::Bool\n\n# Logical constraints: if p then q, if q then r\nimplications = Constraints([\n    !p | q,  # p => q\n    !q | r   # q => r\n])\n\n# If p is true, is r necessarily true?\nisprovable(p => r, implications)  # true (transitivity)\n\n# Can all three be false?\nissatisfiable(!p & !q & !r, implications)  # true","category":"section"},{"location":"manual/sat_solving/#Example-3:-Optimization-Bounds","page":"SAT Solving","title":"Example 3: Optimization Bounds","text":"@variables x::Real y::Real\n\n# Feasible region for optimization\nfeasible = Constraints([\n    x >= 0, y >= 0,           # Non-negativity\n    x + y <= 10,              # Resource constraint\n    2*x + y <= 15             # Additional constraint\n])\n\n# Is the origin feasible?\nissatisfiable(x == 0 & y == 0, feasible)  # true\n\n# Is there a solution with both variables > 5?\nissatisfiable(x > 5 & y > 5, feasible)    # false","category":"section"},{"location":"manual/sat_solving/#Advanced-SAT-Solving-Concepts","page":"SAT Solving","title":"Advanced SAT Solving Concepts","text":"","category":"section"},{"location":"manual/sat_solving/#Contradiction-Detection","page":"SAT Solving","title":"Contradiction Detection","text":"Detect when constraint sets are unsatisfiable:\n\ncontradictory = Constraints([x > 5, x < 3])\n\n# Any expression is unsatisfiable with contradictory constraints\nissatisfiable(true, contradictory)   # false\nissatisfiable(x == 4, contradictory) # false","category":"section"},{"location":"manual/sat_solving/#Implication-Checking","page":"SAT Solving","title":"Implication Checking","text":"Check if one expression implies another:\n\n@variables a::Real b::Real\n\nconstraints = Constraints([a > 0, b > 0])\n\n# Does a > 5 imply a + b > 5?\n# This is equivalent to: isprovable(a + b > 5, constraints * {a > 5})\nextended = Constraints([a > 0, b > 0, a > 5])\nisprovable(a + b > 5, extended)  # true","category":"section"},{"location":"manual/sat_solving/#Equivalence-Checking","page":"SAT Solving","title":"Equivalence Checking","text":"Check if two expressions are equivalent under constraints:\n\nexpr1 = x + y\nexpr2 = y + x\n\n# Are they equivalent? (Check both directions)\nleft_to_right = isprovable(expr1 == expr2, constraints)   # true\nright_to_left = isprovable(expr2 == expr1, constraints)   # true","category":"section"},{"location":"manual/sat_solving/#Solver-Limitations","page":"SAT Solving","title":"Solver Limitations","text":"","category":"section"},{"location":"manual/sat_solving/#Current-Limitations","page":"SAT Solving","title":"Current Limitations","text":"Real arithmetic: Currently mapped to integer arithmetic in Z3\nDivision: Limited support for division operations\nNonlinear expressions: Complex nonlinear constraints may be slow\nQuantifiers: No direct support for universal/existential quantifiers","category":"section"},{"location":"manual/sat_solving/#When-Z3-Cannot-Decide","page":"SAT Solving","title":"When Z3 Cannot Decide","text":"Some problems are undecidable or too complex:\n\n# Very complex nonlinear constraint\ncomplex = Constraints([sin(x*y) + cos(x^2 + y^2) > exp(x - y)])\n\nresult = issatisfiable(x > 0, complex)\n# May return `nothing` if too complex","category":"section"},{"location":"manual/sat_solving/#Debugging-Tips","page":"SAT Solving","title":"Debugging Tips","text":"","category":"section"},{"location":"manual/sat_solving/#Check-Constraint-Satisfiability-First","page":"SAT Solving","title":"Check Constraint Satisfiability First","text":"Always verify your constraints have solutions:\n\ncs = Constraints([...])\nif issatisfiable(true, cs) == false\n    println(\"Warning: Constraint set is unsatisfiable!\")\nend","category":"section"},{"location":"manual/sat_solving/#Simplify-Complex-Expressions","page":"SAT Solving","title":"Simplify Complex Expressions","text":"Break down complex expressions:\n\n# Instead of one complex constraint\ncomplex_expr = (x > 0) & (y > 0) & (x^2 + y^2 < 1) & (x + y > 0.5)\n\n# Use multiple simpler constraints\nsimple_constraints = Constraints([\n    x > 0,\n    y > 0,\n    x^2 + y^2 < 1,\n    x + y > 0.5\n])","category":"section"},{"location":"manual/sat_solving/#Test-with-Known-Solutions","page":"SAT Solving","title":"Test with Known Solutions","text":"Verify your constraint logic with known solutions:\n\ncs = Constraints([x >= 0, y >= 0, x + y <= 1])\n\n# Test a known feasible point\nissatisfiable(x == 0.3 & y == 0.3, cs)  # Should be true\n\n# Test a known infeasible point\nissatisfiable(x == 0.8 & y == 0.8, cs)  # Should be false","category":"section"},{"location":"manual/symbolics_interface/#Symbolics.jl-Interface","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"This page documents the Symbolics.jl frontend API for SymbolicSMT.jl, which provides a modern, user-friendly interface using @variables and Num types.","category":"section"},{"location":"manual/symbolics_interface/#Overview","page":"Symbolics.jl Interface","title":"Overview","text":"The Symbolics.jl interface wraps the core SymbolicUtils.jl backend with convenient dispatch methods that automatically handle conversion between Num and SymbolicUtils.Symbolic types.","category":"section"},{"location":"manual/symbolics_interface/#Variable-Creation","page":"Symbolics.jl Interface","title":"Variable Creation","text":"","category":"section"},{"location":"manual/symbolics_interface/#@variables-Macro","page":"Symbolics.jl Interface","title":"@variables Macro","text":"The @variables macro is re-exported from Symbolics.jl for convenience. It creates symbolic variables with specified types:\n\nusing SymbolicSMT  # @variables is available directly\n\n@variables x::Real y::Real z::Integer p::Bool","category":"section"},{"location":"manual/symbolics_interface/#Constraint-Construction","page":"Symbolics.jl Interface","title":"Constraint Construction","text":"Create constraints from Symbolics.jl Num expressions:\n\n@variables x::Real y::Real\n\n# Create constraints with Symbolics.jl syntax\nconstraints = Constraints([x > 0, y >= 0, x + y < 10])","category":"section"},{"location":"manual/symbolics_interface/#Satisfiability-Checking","page":"Symbolics.jl Interface","title":"Satisfiability Checking","text":"Check if a Num expression can be satisfied:\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true","category":"section"},{"location":"manual/symbolics_interface/#Provability-Checking","page":"Symbolics.jl Interface","title":"Provability Checking","text":"Check if a Num expression is always true:\n\n@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false","category":"section"},{"location":"manual/symbolics_interface/#Expression-Resolution","page":"Symbolics.jl Interface","title":"Expression Resolution","text":"Resolve Num expressions to constants when possible:\n\n@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)","category":"section"},{"location":"manual/symbolics_interface/#Type-Handling","page":"Symbolics.jl Interface","title":"Type Handling","text":"","category":"section"},{"location":"manual/symbolics_interface/#Variable-Types","page":"Symbolics.jl Interface","title":"Variable Types","text":"The Symbolics.jl interface supports all standard variable types:\n\n# Real numbers (continuous)\n@variables position::Real velocity::Real\n\n# Integers (discrete)  \n@variables count::Integer index::Integer\n\n# Booleans (logical)\n@variables active::Bool valid::Bool","category":"section"},{"location":"manual/symbolics_interface/#Expression-Types","page":"Symbolics.jl Interface","title":"Expression Types","text":"All expression types are automatically handled:","category":"section"},{"location":"manual/symbolics_interface/#Arithmetic-Expressions","page":"Symbolics.jl Interface","title":"Arithmetic Expressions","text":"@variables x::Real y::Real\n\nexpr1 = x + y\nexpr2 = 2*x - 3*y  \nexpr3 = x^2 + y^2\nexpr4 = -x + 5","category":"section"},{"location":"manual/symbolics_interface/#Comparison-Expressions","page":"Symbolics.jl Interface","title":"Comparison Expressions","text":"comp1 = x > y\ncomp2 = x >= 0\ncomp3 = x == 5\ncomp4 = x <= 10\ncomp5 = x < y + 1","category":"section"},{"location":"manual/symbolics_interface/#Boolean-Expressions","page":"Symbolics.jl Interface","title":"Boolean Expressions","text":"@variables p::Bool q::Bool\n\nbool1 = p & q\nbool2 = p | q\nbool3 = !p\nbool4 = (p & q) | (!p & !q)","category":"section"},{"location":"manual/symbolics_interface/#Mixed-Expressions","page":"Symbolics.jl Interface","title":"Mixed Expressions","text":"@variables x::Real p::Bool\n\nmixed1 = (x > 0) & p\nmixed2 = p | (x < 5)\nmixed3 = p => (x >= 0)","category":"section"},{"location":"manual/symbolics_interface/#Conversion-Details","page":"Symbolics.jl Interface","title":"Conversion Details","text":"","category":"section"},{"location":"manual/symbolics_interface/#Automatic-Unwrapping","page":"Symbolics.jl Interface","title":"Automatic Unwrapping","text":"Num expressions are automatically unwrapped to SymbolicUtils.Symbolic:\n\n@variables x::Real\nnum_expr = x > 0                    # Symbolics.Num\nsymbolic_expr = unwrap(num_expr)    # SymbolicUtils.BasicSymbolic{Bool}","category":"section"},{"location":"manual/symbolics_interface/#Automatic-Wrapping","page":"Symbolics.jl Interface","title":"Automatic Wrapping","text":"Results are wrapped back to Num when appropriate:\n\nresult = resolve(x > 10, constraints)\n# If cannot resolve: returns Num\n# If resolves to bool: returns Bool","category":"section"},{"location":"manual/symbolics_interface/#Type-Preservation","page":"Symbolics.jl Interface","title":"Type Preservation","text":"The interface preserves semantic meaning:\n\n# Input: Num expression\n# Processing: SymbolicUtils backend\n# Output: Appropriate type (Bool for constants, Num for expressions)","category":"section"},{"location":"manual/symbolics_interface/#Usage-Patterns","page":"Symbolics.jl Interface","title":"Usage Patterns","text":"","category":"section"},{"location":"manual/symbolics_interface/#Basic-Workflow","page":"Symbolics.jl Interface","title":"Basic Workflow","text":"using Symbolics, SymbolicSMT\n\n# 1. Create variables\n@variables x::Real y::Real\n\n# 2. Define constraints  \nconstraints = Constraints([x >= 0, y >= 0])\n\n# 3. Query system\nresult1 = issatisfiable(x + y > 5, constraints)  \nresult2 = isprovable(x >= 0, constraints)\nresult3 = resolve(x > 10, constraints)","category":"section"},{"location":"manual/symbolics_interface/#Advanced-Usage","page":"Symbolics.jl Interface","title":"Advanced Usage","text":"# Mixed variable types\n@variables pos::Real vel::Real gear::Integer active::Bool\n\n# Complex constraint set\nconstraints = Constraints([\n    pos >= 0,                           # Real constraint\n    vel >= 0, vel <= 120,              # Real bounds\n    gear >= 1, gear <= 5,              # Integer constraint\n    active,                             # Boolean constraint\n    active => (vel > 0),               # Conditional constraint\n    (gear > 3) => (vel > 50)          # Gear-speed relationship\n])\n\n# Complex queries\ncan_be_stationary = issatisfiable(vel == 0, constraints)\nalways_moving = isprovable(vel > 0, constraints)  \nhigh_gear_fast = isprovable((gear > 3) => (vel > 50), constraints)","category":"section"},{"location":"manual/symbolics_interface/#Comparison-with-SymbolicUtils-Interface","page":"Symbolics.jl Interface","title":"Comparison with SymbolicUtils Interface","text":"","category":"section"},{"location":"manual/symbolics_interface/#Symbolics.jl-Interface-(Recommended)","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface (Recommended)","text":"using Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nresult = issatisfiable(x + y > 1, constraints)\n\nBenefits:\n\nModern Julia ecosystem standard\nClean @variables syntax\nAutomatic type handling\nBetter integration with other packages","category":"section"},{"location":"manual/symbolics_interface/#SymbolicUtils.jl-Interface","page":"Symbolics.jl Interface","title":"SymbolicUtils.jl Interface","text":"using SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real  \nconstraints = Constraints([x > 0, y > 0])\nresult = issatisfiable(x + y > 1, constraints)\n\nWhen to use:\n\nAdvanced symbolic manipulation\nCustom symbolic operations\nLower-level control\nExisting SymbolicUtils.jl codebase","category":"section"},{"location":"manual/symbolics_interface/#Mixed-Usage","page":"Symbolics.jl Interface","title":"Mixed Usage","text":"Both interfaces can be used together:\n\nusing Symbolics, SymbolicUtils, SymbolicSMT\n\n# Mix Symbolics and SymbolicUtils variables\n@variables x::Real          # Symbolics.Num\n@syms y::Real              # SymbolicUtils.Symbolic\n\n# Both work in the same constraint set\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)  # Works seamlessly","category":"section"},{"location":"manual/symbolics_interface/#Error-Handling","page":"Symbolics.jl Interface","title":"Error Handling","text":"The Symbolics.jl interface provides the same error handling as the SymbolicUtils backend:","category":"section"},{"location":"manual/symbolics_interface/#Conversion-Errors","page":"Symbolics.jl Interface","title":"Conversion Errors","text":"# If expressions cannot be converted to Z3\ntry\n    constraints = Constraints([unsupported_expr])\ncatch e\n    # Detailed error message about conversion failure\n    println(e)\nend","category":"section"},{"location":"manual/symbolics_interface/#Type-Mismatches","page":"Symbolics.jl Interface","title":"Type Mismatches","text":"# Type mismatches are caught during unwrapping\n@variables x::Real\n\n# This would cause an error if x is used in boolean context incorrectly\n# The error message will indicate the type mismatch","category":"section"},{"location":"manual/symbolics_interface/#Performance-Notes","page":"Symbolics.jl Interface","title":"Performance Notes","text":"","category":"section"},{"location":"manual/symbolics_interface/#Zero-Overhead-Design","page":"Symbolics.jl Interface","title":"Zero Overhead Design","text":"The Symbolics.jl interface adds minimal overhead:\n\nDispatch cost: Single method lookup\nConversion cost: Simple unwrap/wrap operations  \nBackend unchanged: Same optimized SymbolicUtils processing","category":"section"},{"location":"manual/symbolics_interface/#Memory-Usage","page":"Symbolics.jl Interface","title":"Memory Usage","text":"Shared backend: No duplication of solver state\nMinimal wrappers: Num types are lightweight wrappers\nEfficient conversion: Direct delegation without copying","category":"section"},{"location":"manual/symbolics_interface/#Recommendations","page":"Symbolics.jl Interface","title":"Recommendations","text":"For best performance:\n\nBatch constraint creation rather than creating many small sets\nUse appropriate variable types for your problem domain\nPrefer the Symbolics interface for new code (better ecosystem integration)\nMix interfaces judiciously - conversion has minimal but non-zero cost","category":"section"},{"location":"manual/symbolics_interface/#SymbolicSMT.Constraints-Tuple{Vector{Num}, String}","page":"Symbolics.jl Interface","title":"SymbolicSMT.Constraints","text":"Constraints(constraints::Vector{Num}, solvertype=\"QF_NRA\")\n\nCreate constraints from Symbolics.jl Num expressions.\n\nThis is a convenience constructor that accepts Num types from Symbolics.jl, unwraps them to SymbolicUtils expressions, and creates the constraint set.\n\nArguments\n\nconstraints::Vector{Num}: Vector of boolean Symbolics.jl Num expressions\nsolvertype::String=\"QF_NRA\": Z3 solver type to use\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\n\n# Create constraints with Symbolics.jl syntax\nconstraints = Constraints([x > 0, y >= 0, x + y < 10])\n\n# Use with standard SymbolicSMT functions\nissatisfiable(x + y > 5, constraints)\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/#SymbolicSMT.issatisfiable-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.issatisfiable","text":"issatisfiable(expr::Num, constraints::Constraints)\n\nCheck satisfiability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Check with Symbolics.jl Num expressions\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/#SymbolicSMT.isprovable-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.isprovable","text":"isprovable(expr::Num, constraints::Constraints)\n\nCheck provability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provably true under the constraints\nfalse: The expression can be false under the constraints\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Check provability with Symbolics.jl\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/#SymbolicSMT.resolve-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.resolve","text":"resolve(expr::Num, constraints::Constraints)\n\nResolve a Symbolics.jl Num expression to a boolean constant if possible.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, delegates to the core implementation, and wraps boolean results back to Num if needed.\n\nArguments\n\nexpr::Num: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nNum: The wrapped original expression if it cannot be resolved\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)\n\n\n\n\n\n","category":"method"},{"location":"#SymbolicSMT.jl","page":"Home","title":"SymbolicSMT.jl","text":"Satisfiability solving for symbolic expressions\n\nSymbolicSMT.jl provides an interface between SymbolicUtils.jl and Symbolics.jl symbolic expressions and the Z3 satisfiability modulo theories (SMT) solver. This allows you to check satisfiability and provability of symbolic boolean expressions containing arithmetic constraints.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Symbolics.jl integration: Work with @variables and Num types from Symbolics.jl\nSymbolicUtils.jl support: Direct compatibility with SymbolicUtils expressions\nZ3 integration: Leverage the power of Microsoft Research's Z3 solver  \nMultiple theories: Support for linear and nonlinear real arithmetic\nSatisfiability checking: Determine if constraints have solutions\nProvability checking: Verify if statements are always true under constraints","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SymbolicSMT\")","category":"section"},{"location":"#Quick-Example-with-Symbolics.jl","page":"Home","title":"Quick Example with Symbolics.jl","text":"using Symbolics, SymbolicSMT\n\n# Create symbolic variables with Symbolics.jl\n@variables x::Real y::Real\n\n# Define constraints: both variables are positive\nconstraints = Constraints([x > 0, y > 0])\n\n# Check satisfiability: Can x + y be greater than 1?\nissatisfiable(x + y > 1, constraints)  # true\n\n# Check provability: Is x + y always positive?\nisprovable(x + y > 0, constraints)     # true\n\n# Check provability: Is x always greater than y?\nisprovable(x > y, constraints)         # false\n\n# Resolve expressions to constants when possible\nresolve(x > 0, constraints)     # true (always true)\nresolve(x > 10, constraints)    # x > 10 (cannot determine)","category":"section"},{"location":"#Alternative:-SymbolicUtils.jl-Interface","page":"Home","title":"Alternative: SymbolicUtils.jl Interface","text":"SymbolicSMT.jl also supports the lower-level SymbolicUtils.jl interface:\n\nusing SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)  # true","category":"section"},{"location":"#Package-Ecosystem","page":"Home","title":"Package Ecosystem","text":"SymbolicSMT.jl is part of the JuliaSymbolics ecosystem and works seamlessly with:\n\nSymbolics.jl: High-level symbolic computation and modeling\nSymbolicUtils.jl: Core symbolic expression manipulation\nModelingToolkit.jl: Symbolic-numeric modeling","category":"section"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"Z3.jl: Julia bindings for the Z3 theorem prover\nJuMP.jl: Mathematical optimization in Julia\nSatisfiability.jl: Alternative SAT/SMT interface","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Documentation: Browse the manual and API reference in the sidebar\nExamples: Check out the tutorials for practical usage patterns\nIssues: Report bugs or request features on GitHub\nDiscussions: Join the community on the Julia Discourse","category":"section"}]
}
