var documenterSearchIndex = {"docs":
[{"location":"manual/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"This section explains how to create and work with constraints in SymbolicSMT.jl.","category":"page"},{"location":"manual/constraints/#What-are-Constraints?","page":"Constraints","title":"What are Constraints?","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Constraints are boolean expressions that define the valid domain for your variables. They represent the conditions that must be satisfied in any solution to your problem.","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"using Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\n\n# These are constraints:\nx > 0           # x must be positive\ny >= -2         # y must be at least -2  \nx + y < 10      # sum must be less than 10\nx^2 + y^2 <= 1  # point must be inside unit circle","category":"page"},{"location":"manual/constraints/#Creating-Constraint-Sets","page":"Constraints","title":"Creating Constraint Sets","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use the Constraints constructor to create a collection of constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# Single constraint\nconstraints1 = Constraints([x > 0])\n\n# Multiple constraints (all must be satisfied)\nconstraints2 = Constraints([\n    x > 0,\n    y >= 0, \n    x + y <= 10,\n    x - y >= -5\n])","category":"page"},{"location":"manual/constraints/#Types-of-Constraints","page":"Constraints","title":"Types of Constraints","text":"","category":"section"},{"location":"manual/constraints/#Linear-Constraints","page":"Constraints","title":"Linear Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Linear constraints involve variables with power 1:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables x::Real y::Real z::Real\n\nlinear_constraints = Constraints([\n    x + 2*y - 3*z <= 5,\n    x - y >= 0,\n    2*x + y == 7\n])","category":"page"},{"location":"manual/constraints/#Quadratic-Constraints","page":"Constraints","title":"Quadratic Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Quadratic constraints involve squared terms:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"quadratic_constraints = Constraints([\n    x^2 + y^2 <= 1,    # Circle constraint\n    x^2 - y >= 0,      # Parabola constraint\n    (x - 1)^2 + (y - 2)^2 <= 4  # Circle centered at (1,2)\n])","category":"page"},{"location":"manual/constraints/#Boolean-Constraints","page":"Constraints","title":"Boolean Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Boolean constraints involve logical variables and operations:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables p::Bool q::Bool r::Bool\n\nboolean_constraints = Constraints([\n    p,              # p must be true\n    !q | r,         # either q is false or r is true\n    p & (q | !r)    # p and (q or not r)\n])","category":"page"},{"location":"manual/constraints/#Mixed-Constraints","page":"Constraints","title":"Mixed Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Combine different types of variables and constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables x::Real n::Integer valid::Bool\n\nmixed_constraints = Constraints([\n    x >= 0,                    # Real constraint\n    n >= 1,                    # Integer constraint\n    valid | (x < n),           # Boolean + mixed constraint\n    x^2 + n <= 10              # Nonlinear mixed constraint\n])","category":"page"},{"location":"manual/constraints/#Constraint-Evaluation","page":"Constraints","title":"Constraint Evaluation","text":"","category":"section"},{"location":"manual/constraints/#Empty-Constraint-Sets","page":"Constraints","title":"Empty Constraint Sets","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Empty constraint sets are always satisfiable:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"empty_constraints = Constraints([])\nissatisfiable(x > 100, empty_constraints)  # true - no restrictions","category":"page"},{"location":"manual/constraints/#Contradictory-Constraints","page":"Constraints","title":"Contradictory Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Some constraint sets have no solutions:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"impossible = Constraints([x > 5, x < 3])\nissatisfiable(true, impossible)  # false - constraint set is unsatisfiable","category":"page"},{"location":"manual/constraints/#Redundant-Constraints","page":"Constraints","title":"Redundant Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Some constraints may be implied by others:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# The second constraint is redundant\nredundant = Constraints([x > 5, x > 3])  # x > 3 is implied by x > 5","category":"page"},{"location":"manual/constraints/#Working-with-Constraint-Objects","page":"Constraints","title":"Working with Constraint Objects","text":"","category":"section"},{"location":"manual/constraints/#Inspecting-Constraints","page":"Constraints","title":"Inspecting Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"You can examine the constraints in a Constraints object:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"cs = Constraints([x > 0, y <= 5])\nprintln(cs)  # Shows: Constraints: x > 0 ' y <= 5\n\n# Access the constraint expressions\ncs.constraints  # Vector of original expressions","category":"page"},{"location":"manual/constraints/#Constraint-Context","page":"Constraints","title":"Constraint Context","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Each Constraints object maintains its own Z3 solver context:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"cs = Constraints([x > 0])\n# cs.solver contains the Z3 solver\n# cs.context contains the Z3 context","category":"page"},{"location":"manual/constraints/#Advanced-Constraint-Patterns","page":"Constraints","title":"Advanced Constraint Patterns","text":"","category":"section"},{"location":"manual/constraints/#Conditional-Constraints","page":"Constraints","title":"Conditional Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Use boolean variables to create conditional constraints:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables x::Real active::Bool\n\nconditional = Constraints([\n    active => (x > 0),  # If active, then x > 0\n    !active => (x <= 0) # If not active, then x <= 0\n])","category":"page"},{"location":"manual/constraints/#Range-Constraints","page":"Constraints","title":"Range Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Define variables within specific ranges:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables angle::Real\n\n# Angle between 0 and 2*pi\nangle_constraints = Constraints([\n    angle >= 0,\n    angle <= 2*pi\n])","category":"page"},{"location":"manual/constraints/#Geometric-Constraints","page":"Constraints","title":"Geometric Constraints","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Model geometric relationships:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables x1::Real y1::Real x2::Real y2::Real\n\n# Two points on the unit circle\nunit_circle = Constraints([\n    x1^2 + y1^2 == 1,\n    x2^2 + y2^2 == 1\n])\n\n# Distance constraint\ndistance_constraint = Constraints([\n    (x1 - x2)^2 + (y1 - y2)^2 <= 1  # Points within distance 1\n])","category":"page"},{"location":"manual/constraints/#Tips-for-Effective-Constraint-Design","page":"Constraints","title":"Tips for Effective Constraint Design","text":"","category":"section"},{"location":"manual/constraints/#1.-Start-Simple","page":"Constraints","title":"1. Start Simple","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Begin with simple constraints and add complexity gradually:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# Start with basic bounds\nbasic = Constraints([x >= 0, y >= 0])\n\n# Add more specific constraints\nrefined = Constraints([x >= 0, y >= 0, x + y <= 10, x - y >= -2])","category":"page"},{"location":"manual/constraints/#2.-Use-Appropriate-Types","page":"Constraints","title":"2. Use Appropriate Types","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Choose variable types that match your problem:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# For continuous optimization\n@variables position::Real velocity::Real\n\n# For counting problems  \n@variables count::Integer items::Integer\n\n# For logical conditions\n@variables enabled::Bool valid::Bool","category":"page"},{"location":"manual/constraints/#3.-Structure-Boolean-Logic","page":"Constraints","title":"3. Structure Boolean Logic","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Make boolean expressions as simple as possible:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# Prefer simple forms\nsimple = Constraints([p, !q])\n\n# Over complex nested expressions\ncomplex = Constraints([((p & q) | (!p & !q)) & (p | q)])","category":"page"},{"location":"manual/constraints/#4.-Check-Constraint-Satisfiability","page":"Constraints","title":"4. Check Constraint Satisfiability","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"Always verify your constraint set has solutions:","category":"page"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"cs = Constraints([x > 5, x < 3])  # Oops! No solutions\nissatisfiable(true, cs)  # false - indicates problem with constraints","category":"page"},{"location":"manual/constraints/#Common-Patterns","page":"Constraints","title":"Common Patterns","text":"","category":"section"},{"location":"manual/constraints/#Optimization-Bounds","page":"Constraints","title":"Optimization Bounds","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables x::Real y::Real\n\nbounds = Constraints([\n    x >= -10, x <= 10,\n    y >= -10, y <= 10\n])","category":"page"},{"location":"manual/constraints/#Non-negativity","page":"Constraints","title":"Non-negativity","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"non_negative = Constraints([x >= 0, y >= 0, z >= 0])","category":"page"},{"location":"manual/constraints/#Normalization","page":"Constraints","title":"Normalization","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"# Unit vector constraint\nunit_vector = Constraints([x^2 + y^2 + z^2 == 1])","category":"page"},{"location":"manual/constraints/#Mutual-Exclusion","page":"Constraints","title":"Mutual Exclusion","text":"","category":"section"},{"location":"manual/constraints/","page":"Constraints","title":"Constraints","text":"@variables option1::Bool option2::Bool option3::Bool\n\n# Exactly one option must be true\nexactly_one = Constraints([\n    option1 | option2 | option3,           # At least one\n    !(option1 & option2),                  # Not both 1 and 2\n    !(option1 & option3),                  # Not both 1 and 3\n    !(option2 & option3)                   # Not both 2 and 3\n])","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for SymbolicSMT.jl.","category":"page"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#SymbolicSMT.Constraints","page":"API Reference","title":"SymbolicSMT.Constraints","text":"Constraints(constraints::Vector, solvertype=\"QF_NRA\")\n\nA collection of boolean constraints with an associated Z3 solver.\n\nThis type wraps a vector of SymbolicUtils boolean expressions and manages the corresponding Z3 solver context. Constraints are automatically converted to Z3 format and added to the solver upon construction.\n\nArguments\n\nconstraints::Vector: Vector of boolean SymbolicUtils expressions\nsolvertype::String=\"QF_NRA\": Z3 solver type to use\n\nFields\n\nconstraints::Vector: Original SymbolicUtils expressions\nsolver::Z3.Solver: Z3 solver instance with constraints added\ncontext::Z3.Context: Z3 context associated with the solver\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\n# Single constraint\nc1 = Constraints([x > 0])\n\n# Multiple constraints\nc2 = Constraints([x > 0, y > 0, x + y < 10])\n\n# Specify solver type\nc3 = Constraints([x > 0], \"QF_LRA\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Satisfiability-and-Provability","page":"API Reference","title":"Satisfiability and Provability","text":"","category":"section"},{"location":"api/#SymbolicSMT.issatisfiable","page":"API Reference","title":"SymbolicSMT.issatisfiable","text":"issatisfiable(expr, constraints::Constraints)\n\nCheck whether the given expression can be satisfied under the constraints.\n\nDetermines if there exists at least one assignment of variables that makes both the constraints and the expression true.\n\nArguments\n\nexpr: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\nconstraints = Constraints([x > 0, y > 0])\n\n# Can x be negative?\nissatisfiable(x < 0, constraints)  # false\n\n# Can x + y be greater than 1?\nissatisfiable(x + y > 1, constraints)  # true\n\n\n\n\n\nissatisfiable(expr::Bool, ::Constraints)\n\nHandle satisfiability checking for boolean literals.\n\nBoolean literals are trivially satisfiable based on their truth value.\n\nArguments\n\nexpr::Bool: Boolean literal (true or false)\n::Constraints: Constraints (ignored for boolean literals)\n\nReturns\n\nThe boolean value itself.\n\n\n\n\n\nissatisfiable(expr::Num, constraints::Constraints)\n\nCheck satisfiability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Check with Symbolics.jl Num expressions\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true\n\n\n\n\n\n","category":"function"},{"location":"api/#SymbolicSMT.isprovable","page":"API Reference","title":"SymbolicSMT.isprovable","text":"isprovable(expr, constraints::Constraints)\n\nCheck whether the given expression is provable (always true) under the constraints.\n\nAn expression is provable if it is true for all assignments of variables that satisfy the constraints. This is equivalent to checking that the negation of the expression is unsatisfiable under the constraints.\n\nArguments\n\nexpr: Boolean expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provable (always true) given the constraints\nfalse: The expression is not provable given the constraints\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real y::Real\n\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Is x + y always non-negative?\nisprovable(x + y >= 0, constraints)  # true\n\n# Is x always greater than y?\nisprovable(x > y, constraints)  # false\n\n\n\n\n\nisprovable(expr::Num, constraints::Constraints)\n\nCheck provability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provably true under the constraints\nfalse: The expression can be false under the constraints\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Check provability with Symbolics.jl\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false\n\n\n\n\n\n","category":"function"},{"location":"api/#Expression-Resolution","page":"API Reference","title":"Expression Resolution","text":"","category":"section"},{"location":"api/#SymbolicSMT.resolve","page":"API Reference","title":"SymbolicSMT.resolve","text":"resolve(expr, constraints::Constraints)\n\nAttempt to resolve an expression to a boolean constant using the constraints.\n\nTries to determine if the expression is provably true or provably false under the given constraints. If neither can be proven, returns the original expression unchanged.\n\nArguments\n\nexpr: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nexpr: The original expression if it cannot be resolved\n\nExamples\n\nusing SymbolicUtils, SymbolicSMT\n@syms x::Real\n\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)   # true (provable)\nresolve(x < 0, constraints)   # false (provable negation)\nresolve(x > 10, constraints)  # x > 10 (cannot resolve)\n\n\n\n\n\nresolve(expr::Num, constraints::Constraints)\n\nResolve a Symbolics.jl Num expression to a boolean constant if possible.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, delegates to the core implementation, and wraps boolean results back to Num if needed.\n\nArguments\n\nexpr::Num: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nNum: The wrapped original expression if it cannot be resolved\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"manual/basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"This section covers the fundamental concepts and usage patterns in SymbolicSMT.jl.","category":"page"},{"location":"manual/basics/#Overview","page":"Basics","title":"Overview","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"SymbolicSMT.jl bridges the gap between symbolic computation and satisfiability solving. It allows you to:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Define symbolic constraints on real, integer, and boolean variables\nCheck if logical expressions are satisfiable under those constraints  \nProve or disprove symbolic statements\nSimplify expressions using constraint-based reasoning","category":"page"},{"location":"manual/basics/#The-SymbolicSMT-Workflow","page":"Basics","title":"The SymbolicSMT Workflow","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"The typical workflow involves three main steps:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Create symbolic variables using Symbolics.jl or SymbolicUtils.jl\nDefine constraints that bound the problem domain\nQuery satisfiability or provability of expressions","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"using Symbolics, SymbolicSMT\n\n# Step 1: Create variables\n@variables x::Real y::Real\n\n# Step 2: Define constraints\nconstraints = Constraints([x >= 0, y >= 0, x + y <= 10])\n\n# Step 3: Query the system\nissatisfiable(x + y > 5, constraints)  # true\nisprovable(x >= 0, constraints)        # true","category":"page"},{"location":"manual/basics/#Types-of-Variables","page":"Basics","title":"Types of Variables","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"SymbolicSMT.jl supports different types of symbolic variables:","category":"page"},{"location":"manual/basics/#Real-Variables","page":"Basics","title":"Real Variables","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Real variables represent continuous numeric values:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"@variables x::Real y::Real temperature::Real","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"These can be used in arithmetic expressions and inequality constraints.","category":"page"},{"location":"manual/basics/#Integer-Variables","page":"Basics","title":"Integer Variables","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Integer variables represent discrete numeric values:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"@variables n::Integer count::Integer age::Integer","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Integer variables support the same operations as real variables but are constrained to integer solutions.","category":"page"},{"location":"manual/basics/#Boolean-Variables","page":"Basics","title":"Boolean Variables","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Boolean variables represent logical values:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"@variables p::Bool flag::Bool condition::Bool","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Boolean variables are useful for encoding logical relationships and conditional constraints.","category":"page"},{"location":"manual/basics/#Supported-Operations","page":"Basics","title":"Supported Operations","text":"","category":"section"},{"location":"manual/basics/#Arithmetic-Operations","page":"Basics","title":"Arithmetic Operations","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Addition: x + y, x + 5\nSubtraction: x - y, x - 3  \nMultiplication: x * y, 2 * x\nPowers: x^2, x^n\nUnary minus: -x","category":"page"},{"location":"manual/basics/#Comparison-Operations","page":"Basics","title":"Comparison Operations","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Equal: x == y\nGreater than: x > y\nGreater than or equal: x >= y  \nLess than: x < y\nLess than or equal: x <= y","category":"page"},{"location":"manual/basics/#Logical-Operations","page":"Basics","title":"Logical Operations","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"AND: p & q\nOR: p | q\nNOT: !p","category":"page"},{"location":"manual/basics/#Type-System-Integration","page":"Basics","title":"Type System Integration","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"SymbolicSMT.jl handles the conversion between Symbolics/SymbolicUtils types and Z3 types:","category":"page"},{"location":"manual/basics/#Supported-Type-Mappings","page":"Basics","title":"Supported Type Mappings","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Real -> Z3 Int (current implementation treats reals as integers)\nInteger -> Z3 Int\nBool -> Z3 Bool","category":"page"},{"location":"manual/basics/#Automatic-Conversion","page":"Basics","title":"Automatic Conversion","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"The conversion happens automatically when creating constraints:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"@variables x::Real p::Bool\nconstraints = Constraints([x > 0, p])  # Automatic type conversion","category":"page"},{"location":"manual/basics/#Frontend-Interfaces","page":"Basics","title":"Frontend Interfaces","text":"","category":"section"},{"location":"manual/basics/#Symbolics.jl-Interface-(Recommended)","page":"Basics","title":"Symbolics.jl Interface (Recommended)","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"The modern, user-friendly interface using @variables:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"using Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)","category":"page"},{"location":"manual/basics/#SymbolicUtils.jl-Interface","page":"Basics","title":"SymbolicUtils.jl Interface","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"The lower-level interface for advanced users:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"using SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])  \nissatisfiable(x + y > 1, constraints)","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Both interfaces can be mixed in the same code.","category":"page"},{"location":"manual/basics/#Performance-Considerations","page":"Basics","title":"Performance Considerations","text":"","category":"section"},{"location":"manual/basics/#Solver-Complexity","page":"Basics","title":"Solver Complexity","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Different constraint types have different computational complexity:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Linear arithmetic: Generally efficient\nNonlinear arithmetic: More expensive\nBoolean satisfiability: Depends on structure\nMixed integer: Can be challenging","category":"page"},{"location":"manual/basics/#Best-Practices","page":"Basics","title":"Best Practices","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"Keep constraints simple when possible\nUse appropriate variable types (prefer Real over Integer when exact integers aren't required)\nBatch constraint creation rather than creating many small constraint sets\nStructure boolean expressions to be as simple as possible","category":"page"},{"location":"manual/basics/#Error-Handling","page":"Basics","title":"Error Handling","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"SymbolicSMT.jl provides informative error messages when expressions cannot be converted:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"# This will show what failed to convert if there are unsupported operations\ntry\n    constraints = Constraints([some_unsupported_expr])\ncatch e\n    println(e)  # Detailed error message\nend","category":"page"},{"location":"manual/basics/#Understanding-Results","page":"Basics","title":"Understanding Results","text":"","category":"section"},{"location":"manual/basics/#Satisfiability-Results","page":"Basics","title":"Satisfiability Results","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"issatisfiable returns:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"true: There exists at least one solution\nfalse: No solution exists  \nnothing: The solver cannot determine (rare)","category":"page"},{"location":"manual/basics/#Provability-Results","page":"Basics","title":"Provability Results","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"isprovable returns:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"true: The statement is always true under the constraints\nfalse: The statement can be false under the constraints","category":"page"},{"location":"manual/basics/#Resolution-Results","page":"Basics","title":"Resolution Results","text":"","category":"section"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"resolve returns:","category":"page"},{"location":"manual/basics/","page":"Basics","title":"Basics","text":"true: The expression is provably true\nfalse: The expression is provably false\nOriginal expression (as Num or Symbolic): Cannot be determined","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial will walk you through the basics of using SymbolicSMT.jl to solve symbolic constraint problems.","category":"page"},{"location":"getting_started/#Installation-and-Setup","page":"Getting Started","title":"Installation and Setup","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, install the required packages:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add([\"SymbolicSMT\", \"Symbolics\"])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Then load the packages:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Symbolics, SymbolicSMT","category":"page"},{"location":"getting_started/#Creating-Symbolic-Variables-with-Symbolics.jl","page":"Getting Started","title":"Creating Symbolic Variables with Symbolics.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SymbolicSMT.jl works seamlessly with Symbolics.jl @variables and Num types:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables x::Real y::Real z::Integer p::Bool","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This creates symbolic variables: x and y as real numbers, z as an integer, and p as a boolean.","category":"page"},{"location":"getting_started/#Defining-Constraints","page":"Getting Started","title":"Defining Constraints","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Constraints are collections of boolean expressions that must be satisfied. Create constraints using the Constraints constructor:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Simple constraints with Symbolics.jl variables\nconstraints = Constraints([\n    x > 0,      # x must be positive\n    y >= -2,    # y must be at least -2\n    x + y < 10  # sum must be less than 10\n])","category":"page"},{"location":"getting_started/#Checking-Satisfiability","page":"Getting Started","title":"Checking Satisfiability","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Use issatisfiable to check if an expression can be true given the constraints:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Can x be greater than 5?\nissatisfiable(x > 5, constraints)  # true - possible\n\n# Can x be negative?\nissatisfiable(x < 0, constraints)  # false - conflicts with x > 0\n\n# Can x + y equal 15?\nissatisfiable(x + y == 15, constraints)  # false - conflicts with x + y < 10","category":"page"},{"location":"getting_started/#Checking-Provability","page":"Getting Started","title":"Checking Provability","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Use isprovable to check if an expression is always true given the constraints:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Is x always positive?\nisprovable(x > 0, constraints)     # true - follows from constraints\n\n# Is x always greater than y?\nisprovable(x > y, constraints)     # false - not necessarily true","category":"page"},{"location":"getting_started/#Expression-Resolution","page":"Getting Started","title":"Expression Resolution","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The resolve function attempts to simplify expressions to boolean constants:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables t::Real\ntime_constraints = Constraints([t >= 0, t <= 24])  # Time in hours\n\n# These resolve to constants\nresolve(t >= 0, time_constraints)   # true (always true)\nresolve(t < 0, time_constraints)    # false (never true)\n\n# This cannot be resolved (returns original Num expression)\nresolve(t > 12, time_constraints)   # t > 12 (unchanged)","category":"page"},{"location":"getting_started/#Working-with-Different-Variable-Types","page":"Getting Started","title":"Working with Different Variable Types","text":"","category":"section"},{"location":"getting_started/#Real-Variables","page":"Getting Started","title":"Real Variables","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables x::Real y::Real temperature::Real\n\nconstraints = Constraints([x >= 0, y >= 0, temperature > 273.15])\nissatisfiable(x + y > temperature, constraints)","category":"page"},{"location":"getting_started/#Integer-Variables","page":"Getting Started","title":"Integer Variables","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables n::Integer count::Integer age::Integer\n\nconstraints = Constraints([n >= 1, count <= 100, age >= 0])\nisprovable(n > 0, constraints)  # true","category":"page"},{"location":"getting_started/#Boolean-Variables","page":"Getting Started","title":"Boolean Variables","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables valid::Bool active::Bool\n\nconstraints = Constraints([valid, !active])  # valid is true, active is false\nisprovable(valid | active, constraints)  # true","category":"page"},{"location":"getting_started/#Complex-Expressions","page":"Getting Started","title":"Complex Expressions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SymbolicSMT.jl supports complex arithmetic and boolean expressions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@variables a::Real b::Real\n\n# Quadratic constraints\nquadratic_constraints = Constraints([\n    a^2 + b^2 <= 1,  # Inside unit circle\n    a >= 0           # First quadrant\n])\n\n# Check complex expressions\nissatisfiable(a * b > 0.1, quadratic_constraints)\nisprovable(a >= 0, quadratic_constraints)  # true","category":"page"},{"location":"getting_started/#Return-Values","page":"Getting Started","title":"Return Values","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Understanding the return values:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"true: The expression is satisfiable/provable\nfalse: The expression is unsatisfiable/not provable  \nnothing: The solver cannot determine the result (rare)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For resolve, boolean results are returned as Bool, while unresolved expressions are returned as Num.","category":"page"},{"location":"getting_started/#Alternative-Interface:-SymbolicUtils.jl","page":"Getting Started","title":"Alternative Interface: SymbolicUtils.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can also use the lower-level SymbolicUtils.jl interface directly:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Read the Manual for deeper understanding of concepts\nCheck out Tutorials for more complex examples\nBrowse the API Reference for complete function documentation","category":"page"},{"location":"tutorials/basic_examples/#Basic-Examples","page":"Basic Examples","title":"Basic Examples","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"This tutorial provides practical examples of using SymbolicSMT.jl for various types of problems.","category":"page"},{"location":"tutorials/basic_examples/#Example-1:-Planning-and-Scheduling","page":"Basic Examples","title":"Example 1: Planning and Scheduling","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Let's solve a simple resource allocation problem:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"using Symbolics, SymbolicSMT\n\n# Define variables: time allocated to each task (in hours)\n@variables task1::Real task2::Real task3::Real\n\n# Constraints: budget and minimum requirements\nconstraints = Constraints([\n    task1 >= 2,           # Task 1 needs at least 2 hours\n    task2 >= 1,           # Task 2 needs at least 1 hour  \n    task3 >= 3,           # Task 3 needs at least 3 hours\n    task1 + task2 + task3 <= 10  # Total budget is 10 hours\n])\n\n# Questions we can ask:\nissatisfiable(task1 + task2 + task3 == 10, constraints)  # true - can use full budget\nissatisfiable(task1 > 5, constraints)                    # true - task1 can be > 5\nissatisfiable(task1 > 6, constraints)                    # false - would exceed budget","category":"page"},{"location":"tutorials/basic_examples/#Example-2:-Geometric-Reasoning","page":"Basic Examples","title":"Example 2: Geometric Reasoning","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Solve problems involving geometric shapes and relationships:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables x::Real y::Real\n\n# Point inside unit circle\ninside_circle = Constraints([x^2 + y^2 <= 1])\n\n# Point in first quadrant\nfirst_quadrant = Constraints([x >= 0, y >= 0])\n\n# Combined constraints\nconstraints = Constraints([x^2 + y^2 <= 1, x >= 0, y >= 0])\n\n# Geometric questions:\nissatisfiable(x > 0.5 & y > 0.5, constraints)           # Check if corner point exists\nisprovable(x >= 0, constraints)                         # true - always in first quadrant  \nissatisfiable(x^2 + y^2 > 0.9, constraints)            # true - can be near boundary","category":"page"},{"location":"tutorials/basic_examples/#Example-3:-Logic-Puzzles","page":"Basic Examples","title":"Example 3: Logic Puzzles","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Solve propositional logic problems:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables alice_tall::Bool bob_tall::Bool charlie_tall::Bool\n\n# Logic puzzle constraints:\n# 1. At least one person is tall\n# 2. If Alice is tall, then Bob is not tall\n# 3. Charlie is tall if and only if exactly one of Alice/Bob is tall\n\npuzzle_constraints = Constraints([\n    alice_tall | bob_tall | charlie_tall,              # At least one tall\n    !alice_tall | !bob_tall,                           # Alice tall => Bob not tall\n    charlie_tall == ((alice_tall & !bob_tall) | (!alice_tall & bob_tall))  # Charlie iff exactly one\n])\n\n# Solution questions:\nissatisfiable(alice_tall & !bob_tall & charlie_tall, puzzle_constraints)  # Check specific solution\nisprovable(charlie_tall => (alice_tall | bob_tall), puzzle_constraints)   # Logical implication","category":"page"},{"location":"tutorials/basic_examples/#Example-4:-System-Configuration","page":"Basic Examples","title":"Example 4: System Configuration","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Model system configuration constraints:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables memory::Integer cores::Integer storage::Integer\n\n# System requirements\nsystem_constraints = Constraints([\n    memory >= 4,           # At least 4GB RAM\n    cores >= 2,            # At least 2 CPU cores\n    storage >= 100,        # At least 100GB storage\n    memory * cores <= 32,  # Memory-core product limit\n    storage <= 1000        # Storage upper limit\n])\n\n# Configuration questions:\nissatisfiable(memory == 8 & cores == 4, system_constraints)      # Valid config?\nisprovable(memory + cores >= 6, system_constraints)              # Always true?\nissatisfiable(memory > 16 & cores > 4, system_constraints)       # High-end possible?","category":"page"},{"location":"tutorials/basic_examples/#Example-5:-Financial-Modeling","page":"Basic Examples","title":"Example 5: Financial Modeling","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Model financial constraints and optimization:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables stocks::Real bonds::Real cash::Real\n\n# Portfolio constraints\nportfolio_constraints = Constraints([\n    stocks >= 0, bonds >= 0, cash >= 0,    # No short selling\n    stocks + bonds + cash == 100000,       # Total portfolio value\n    stocks <= 60000,                       # Max 60% in stocks\n    cash >= 10000                          # Minimum cash reserve\n])\n\n# Investment questions:\nissatisfiable(stocks > 50000, portfolio_constraints)              # Can we have >50% stocks?\nisprovable(bonds + cash >= 40000, portfolio_constraints)          # Always have 40%+ in bonds/cash?\nresolve(cash >= 10000, portfolio_constraints)                     # true - always satisfied","category":"page"},{"location":"tutorials/basic_examples/#Example-6:-Process-Control","page":"Basic Examples","title":"Example 6: Process Control","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Model control system constraints:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables temperature::Real pressure::Real flow_rate::Real\n\n# Safe operating constraints\nsafety_constraints = Constraints([\n    temperature >= 20, temperature <= 80,     # Temperature range\n    pressure >= 1, pressure <= 5,             # Pressure range  \n    flow_rate >= 0, flow_rate <= 100,         # Flow rate range\n    temperature * pressure <= 300,            # Safety interlock\n    flow_rate <= 2 * pressure                 # Flow depends on pressure\n])\n\n# Safety verification:\nisprovable(temperature <= 80, safety_constraints)                 # Always safe temp?\nissatisfiable(pressure > 4 & flow_rate > 8, safety_constraints)  # High pressure/flow possible?\nresolve(temperature > 60, safety_constraints)                     # Can we run hot?","category":"page"},{"location":"tutorials/basic_examples/#Example-7:-Network-Topology","page":"Basic Examples","title":"Example 7: Network Topology","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Model network connectivity constraints:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables node1_active::Bool node2_active::Bool node3_active::Bool\n@variables link12::Bool link13::Bool link23::Bool\n\n# Network constraints\nnetwork_constraints = Constraints([\n    # Links exist only if both nodes are active\n    link12 => (node1_active & node2_active),\n    link13 => (node1_active & node3_active), \n    link23 => (node2_active & node3_active),\n    \n    # At least one node must be active\n    node1_active | node2_active | node3_active,\n    \n    # Network must be connected (at least one link if multiple nodes)\n    (node1_active & node2_active) => link12,\n    (node1_active & node3_active) => link13,\n    (node2_active & node3_active) => link23\n])\n\n# Network analysis:\nissatisfiable(node1_active & node2_active & !link12, network_constraints)  # false\nisprovable(link12 => (node1_active & node2_active), network_constraints)   # true","category":"page"},{"location":"tutorials/basic_examples/#Example-8:-Hybrid-Systems","page":"Basic Examples","title":"Example 8: Hybrid Systems","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Combine continuous and discrete variables:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"@variables position::Real velocity::Real\n@variables gear::Integer braking::Bool\n\n# Vehicle dynamics constraints\nvehicle_constraints = Constraints([\n    position >= 0,                    # Position bounds\n    velocity >= 0, velocity <= 120,   # Speed limits\n    gear >= 1, gear <= 5,            # Gear range\n    \n    # Gear-speed relationship\n    (gear == 1) => (velocity <= 30),\n    (gear == 2) => (velocity <= 50),\n    (gear == 3) => (velocity <= 70),\n    \n    # Braking physics\n    braking => (velocity <= 60)       # Can't brake effectively at high speed\n])\n\n# Driving scenario analysis:\nissatisfiable(velocity > 80 & gear <= 3, vehicle_constraints)     # Possible?\nisprovable(braking => (gear <= 3), vehicle_constraints)          # Braking implies low gear?","category":"page"},{"location":"tutorials/basic_examples/#Tips-for-Effective-SAT-Solving","page":"Basic Examples","title":"Tips for Effective SAT Solving","text":"","category":"section"},{"location":"tutorials/basic_examples/#1.-Structure-Your-Queries","page":"Basic Examples","title":"1. Structure Your Queries","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Ask specific, well-defined questions:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"# Good: Specific question\nissatisfiable(x > 5 & y < 3, constraints)\n\n# Better: Break down complex queries\nissatisfiable(x > 5, constraints) && issatisfiable(y < 3, constraints)","category":"page"},{"location":"tutorials/basic_examples/#2.-Use-Appropriate-Granularity","page":"Basic Examples","title":"2. Use Appropriate Granularity","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Choose the right level of detail:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"# For rough feasibility\nissatisfiable(x > 0, constraints)\n\n# For precise analysis  \nissatisfiable(x >= 2.5 & x <= 2.6, constraints)","category":"page"},{"location":"tutorials/basic_examples/#3.-Leverage-Provability","page":"Basic Examples","title":"3. Leverage Provability","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Use provability to verify invariants:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"# Safety verification\nisprovable(temperature <= max_temp, safety_constraints)  # Always safe?\n\n# Optimization verification\nisprovable(profit >= 0, business_constraints)            # Always profitable?","category":"page"},{"location":"tutorials/basic_examples/#4.-Combine-Multiple-Queries","page":"Basic Examples","title":"4. Combine Multiple Queries","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"Build complex analysis from simple queries:","category":"page"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"# Check if exactly one solution exists\nhas_solution = issatisfiable(expr, constraints)\nunique_solution = has_solution && isprovable(expr, constraints)","category":"page"},{"location":"tutorials/basic_examples/#Common-Patterns","page":"Basic Examples","title":"Common Patterns","text":"","category":"section"},{"location":"tutorials/basic_examples/#Feasibility-Checking","page":"Basic Examples","title":"Feasibility Checking","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"issatisfiable(candidate_solution, constraints)","category":"page"},{"location":"tutorials/basic_examples/#Invariant-Verification","page":"Basic Examples","title":"Invariant Verification","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"isprovable(safety_property, constraints)","category":"page"},{"location":"tutorials/basic_examples/#Bounds-Analysis","page":"Basic Examples","title":"Bounds Analysis","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"issatisfiable(variable > upper_bound, constraints)  # Can exceed bound?\nisprovable(variable >= lower_bound, constraints)    # Always above bound?","category":"page"},{"location":"tutorials/basic_examples/#Configuration-Validation","page":"Basic Examples","title":"Configuration Validation","text":"","category":"section"},{"location":"tutorials/basic_examples/","page":"Basic Examples","title":"Basic Examples","text":"issatisfiable(configuration_expr, system_constraints)","category":"page"},{"location":"manual/sat_solving/#SAT-Solving","page":"SAT Solving","title":"SAT Solving","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"This section explains the satisfiability solving capabilities of SymbolicSMT.jl.","category":"page"},{"location":"manual/sat_solving/#Satisfiability-vs-Provability","page":"SAT Solving","title":"Satisfiability vs Provability","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"SymbolicSMT.jl provides two main types of queries:","category":"page"},{"location":"manual/sat_solving/#Satisfiability-(issatisfiable)","page":"SAT Solving","title":"Satisfiability (issatisfiable)","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Question: \"Can this expression be true given the constraints?\"","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"using Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Can x be greater than 10?\nissatisfiable(x > 10, constraints)  # true - yes, it's possible","category":"page"},{"location":"manual/sat_solving/#Provability-(isprovable)","page":"SAT Solving","title":"Provability (isprovable)","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Question: \"Is this expression always true given the constraints?\"","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"# Is x always positive?\nisprovable(x > 0, constraints)  # true - yes, always true\n\n# Is x always greater than y?\nisprovable(x > y, constraints)  # false - not necessarily true","category":"page"},{"location":"manual/sat_solving/#Understanding-Return-Values","page":"SAT Solving","title":"Understanding Return Values","text":"","category":"section"},{"location":"manual/sat_solving/#Three-Valued-Logic","page":"SAT Solving","title":"Three-Valued Logic","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Both functions can return three possible values:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"true: Yes (satisfiable/provable)\nfalse: No (unsatisfiable/not provable)\nnothing: Unknown (solver timeout or undecidable)","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"result = issatisfiable(complex_expression, constraints)\n\nif result === true\n    println(\"Satisfiable!\")\nelseif result === false\n    println(\"Unsatisfiable!\")\nelse  # result === nothing\n    println(\"Solver couldn't determine\")\nend","category":"page"},{"location":"manual/sat_solving/#Practical-Interpretation","page":"SAT Solving","title":"Practical Interpretation","text":"","category":"section"},{"location":"manual/sat_solving/#For-issatisfiable:","page":"SAT Solving","title":"For issatisfiable:","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"true: There exists at least one solution\nfalse: No solution exists\nnothing: Solver cannot determine (rare)","category":"page"},{"location":"manual/sat_solving/#For-isprovable:","page":"SAT Solving","title":"For isprovable:","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"true: Statement is always true (tautology under constraints)\nfalse: Statement can be false (not a tautology)\nnothing: Solver cannot determine (rare)","category":"page"},{"location":"manual/sat_solving/#Resolution-with-resolve","page":"SAT Solving","title":"Resolution with resolve","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"The resolve function combines both operations to simplify expressions:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"@variables t::Real\ntime_constraints = Constraints([t >= 0, t <= 24])\n\n# Expressions that resolve to constants\nresolve(t >= 0, time_constraints)   # true (always true)\nresolve(t < 0, time_constraints)    # false (never true)\nresolve(t > 30, time_constraints)   # false (impossible)\n\n# Expressions that cannot be resolved\nresolve(t > 12, time_constraints)   # t > 12 (unchanged)","category":"page"},{"location":"manual/sat_solving/#Practical-Examples","page":"SAT Solving","title":"Practical Examples","text":"","category":"section"},{"location":"manual/sat_solving/#Example-1:-Geometric-Reasoning","page":"SAT Solving","title":"Example 1: Geometric Reasoning","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"@variables x::Real y::Real\n\n# Points inside unit circle\nunit_circle = Constraints([x^2 + y^2 <= 1])\n\n# Can a point be outside the circle?\nissatisfiable(x^2 + y^2 > 1, unit_circle)  # false\n\n# Are all points within distance 1 of origin?\nisprovable(x^2 + y^2 <= 1, unit_circle)    # true","category":"page"},{"location":"manual/sat_solving/#Example-2:-Logical-Reasoning","page":"SAT Solving","title":"Example 2: Logical Reasoning","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"@variables p::Bool q::Bool r::Bool\n\n# Logical constraints: if p then q, if q then r\nimplications = Constraints([\n    !p | q,  # p => q\n    !q | r   # q => r\n])\n\n# If p is true, is r necessarily true?\nisprovable(p => r, implications)  # true (transitivity)\n\n# Can all three be false?\nissatisfiable(!p & !q & !r, implications)  # true","category":"page"},{"location":"manual/sat_solving/#Example-3:-Optimization-Bounds","page":"SAT Solving","title":"Example 3: Optimization Bounds","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"@variables x::Real y::Real\n\n# Feasible region for optimization\nfeasible = Constraints([\n    x >= 0, y >= 0,           # Non-negativity\n    x + y <= 10,              # Resource constraint\n    2*x + y <= 15             # Additional constraint\n])\n\n# Is the origin feasible?\nissatisfiable(x == 0 & y == 0, feasible)  # true\n\n# Is there a solution with both variables > 5?\nissatisfiable(x > 5 & y > 5, feasible)    # false","category":"page"},{"location":"manual/sat_solving/#Advanced-SAT-Solving-Concepts","page":"SAT Solving","title":"Advanced SAT Solving Concepts","text":"","category":"section"},{"location":"manual/sat_solving/#Contradiction-Detection","page":"SAT Solving","title":"Contradiction Detection","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Detect when constraint sets are unsatisfiable:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"contradictory = Constraints([x > 5, x < 3])\n\n# Any expression is unsatisfiable with contradictory constraints\nissatisfiable(true, contradictory)   # false\nissatisfiable(x == 4, contradictory) # false","category":"page"},{"location":"manual/sat_solving/#Implication-Checking","page":"SAT Solving","title":"Implication Checking","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Check if one expression implies another:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"@variables a::Real b::Real\n\nconstraints = Constraints([a > 0, b > 0])\n\n# Does a > 5 imply a + b > 5?\n# This is equivalent to: isprovable(a + b > 5, constraints * {a > 5})\nextended = Constraints([a > 0, b > 0, a > 5])\nisprovable(a + b > 5, extended)  # true","category":"page"},{"location":"manual/sat_solving/#Equivalence-Checking","page":"SAT Solving","title":"Equivalence Checking","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Check if two expressions are equivalent under constraints:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"expr1 = x + y\nexpr2 = y + x\n\n# Are they equivalent? (Check both directions)\nleft_to_right = isprovable(expr1 == expr2, constraints)   # true\nright_to_left = isprovable(expr2 == expr1, constraints)   # true","category":"page"},{"location":"manual/sat_solving/#Solver-Limitations","page":"SAT Solving","title":"Solver Limitations","text":"","category":"section"},{"location":"manual/sat_solving/#Current-Limitations","page":"SAT Solving","title":"Current Limitations","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Real arithmetic: Currently mapped to integer arithmetic in Z3\nDivision: Limited support for division operations\nNonlinear expressions: Complex nonlinear constraints may be slow\nQuantifiers: No direct support for universal/existential quantifiers","category":"page"},{"location":"manual/sat_solving/#When-Z3-Cannot-Decide","page":"SAT Solving","title":"When Z3 Cannot Decide","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Some problems are undecidable or too complex:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"# Very complex nonlinear constraint\ncomplex = Constraints([sin(x*y) + cos(x^2 + y^2) > exp(x - y)])\n\nresult = issatisfiable(x > 0, complex)\n# May return `nothing` if too complex","category":"page"},{"location":"manual/sat_solving/#Debugging-Tips","page":"SAT Solving","title":"Debugging Tips","text":"","category":"section"},{"location":"manual/sat_solving/#Check-Constraint-Satisfiability-First","page":"SAT Solving","title":"Check Constraint Satisfiability First","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Always verify your constraints have solutions:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"cs = Constraints([...])\nif issatisfiable(true, cs) == false\n    println(\"Warning: Constraint set is unsatisfiable!\")\nend","category":"page"},{"location":"manual/sat_solving/#Simplify-Complex-Expressions","page":"SAT Solving","title":"Simplify Complex Expressions","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Break down complex expressions:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"# Instead of one complex constraint\ncomplex_expr = (x > 0) & (y > 0) & (x^2 + y^2 < 1) & (x + y > 0.5)\n\n# Use multiple simpler constraints\nsimple_constraints = Constraints([\n    x > 0,\n    y > 0,\n    x^2 + y^2 < 1,\n    x + y > 0.5\n])","category":"page"},{"location":"manual/sat_solving/#Test-with-Known-Solutions","page":"SAT Solving","title":"Test with Known Solutions","text":"","category":"section"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"Verify your constraint logic with known solutions:","category":"page"},{"location":"manual/sat_solving/","page":"SAT Solving","title":"SAT Solving","text":"cs = Constraints([x >= 0, y >= 0, x + y <= 1])\n\n# Test a known feasible point\nissatisfiable(x == 0.3 & y == 0.3, cs)  # Should be true\n\n# Test a known infeasible point\nissatisfiable(x == 0.8 & y == 0.8, cs)  # Should be false","category":"page"},{"location":"manual/symbolics_interface/#Symbolics.jl-Interface","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"This page documents the Symbolics.jl frontend API for SymbolicSMT.jl, which provides a modern, user-friendly interface using @variables and Num types.","category":"page"},{"location":"manual/symbolics_interface/#Overview","page":"Symbolics.jl Interface","title":"Overview","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The Symbolics.jl interface wraps the core SymbolicUtils.jl backend with convenient dispatch methods that automatically handle conversion between Num and SymbolicUtils.Symbolic types.","category":"page"},{"location":"manual/symbolics_interface/#Variable-Creation","page":"Symbolics.jl Interface","title":"Variable Creation","text":"","category":"section"},{"location":"manual/symbolics_interface/#@variables-Macro","page":"Symbolics.jl Interface","title":"@variables Macro","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The @variables macro is re-exported from Symbolics.jl for convenience. It creates symbolic variables with specified types:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"using SymbolicSMT  # @variables is available directly\n\n@variables x::Real y::Real z::Integer p::Bool","category":"page"},{"location":"manual/symbolics_interface/#Constraint-Construction","page":"Symbolics.jl Interface","title":"Constraint Construction","text":"","category":"section"},{"location":"manual/symbolics_interface/#SymbolicSMT.Constraints-Tuple{Vector{Num}, String}","page":"Symbolics.jl Interface","title":"SymbolicSMT.Constraints","text":"Constraints(constraints::Vector{Num}, solvertype=\"QF_NRA\")\n\nCreate constraints from Symbolics.jl Num expressions.\n\nThis is a convenience constructor that accepts Num types from Symbolics.jl, unwraps them to SymbolicUtils expressions, and creates the constraint set.\n\nArguments\n\nconstraints::Vector{Num}: Vector of boolean Symbolics.jl Num expressions\nsolvertype::String=\"QF_NRA\": Z3 solver type to use\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\n\n# Create constraints with Symbolics.jl syntax\nconstraints = Constraints([x > 0, y >= 0, x + y < 10])\n\n# Use with standard SymbolicSMT functions\nissatisfiable(x + y > 5, constraints)\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Create constraints from Symbolics.jl Num expressions:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real y::Real\n\n# Create constraints with Symbolics.jl syntax\nconstraints = Constraints([x > 0, y >= 0, x + y < 10])","category":"page"},{"location":"manual/symbolics_interface/#Satisfiability-Checking","page":"Symbolics.jl Interface","title":"Satisfiability Checking","text":"","category":"section"},{"location":"manual/symbolics_interface/#SymbolicSMT.issatisfiable-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.issatisfiable","text":"issatisfiable(expr::Num, constraints::Constraints)\n\nCheck satisfiability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Boolean expression to check for satisfiability\nconstraints::Constraints: Constraints that must be satisfied\n\nReturns\n\ntrue: The expression can be satisfied given the constraints\nfalse: The expression cannot be satisfied given the constraints  \nnothing: The solver cannot determine satisfiability (unknown)\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\n# Check with Symbolics.jl Num expressions\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Check if a Num expression can be satisfied:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\n\nissatisfiable(x < 0, constraints)        # false\nissatisfiable(x + y > 1, constraints)    # true","category":"page"},{"location":"manual/symbolics_interface/#Provability-Checking","page":"Symbolics.jl Interface","title":"Provability Checking","text":"","category":"section"},{"location":"manual/symbolics_interface/#SymbolicSMT.isprovable-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.isprovable","text":"isprovable(expr::Num, constraints::Constraints)\n\nCheck provability of a Symbolics.jl Num expression.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, and delegates to the core implementation.\n\nArguments\n\nexpr::Num: Expression to check for provability\nconstraints::Constraints: Constraints under which to check provability\n\nReturns\n\ntrue: The expression is provably true under the constraints\nfalse: The expression can be false under the constraints\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\n# Check provability with Symbolics.jl\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Check if a Num expression is always true:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real y::Real\nconstraints = Constraints([x >= 0, y >= 0])\n\nisprovable(x >= 0, constraints)     # true\nisprovable(x > y, constraints)      # false","category":"page"},{"location":"manual/symbolics_interface/#Expression-Resolution","page":"Symbolics.jl Interface","title":"Expression Resolution","text":"","category":"section"},{"location":"manual/symbolics_interface/#SymbolicSMT.resolve-Tuple{Num, Constraints}","page":"Symbolics.jl Interface","title":"SymbolicSMT.resolve","text":"resolve(expr::Num, constraints::Constraints)\n\nResolve a Symbolics.jl Num expression to a boolean constant if possible.\n\nThis convenience method accepts Num expressions from Symbolics.jl, unwraps them to SymbolicUtils, delegates to the core implementation, and wraps boolean results back to Num if needed.\n\nArguments\n\nexpr::Num: Expression to resolve\nconstraints::Constraints: Constraints to use for resolution\n\nReturns\n\ntrue: If the expression is provably true\nfalse: If the expression is provably false  \nNum: The wrapped original expression if it cannot be resolved\n\nExamples\n\nusing Symbolics, SymbolicSMT\n\n@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)\n\n\n\n\n\n","category":"method"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Resolve Num expressions to constants when possible:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real\nconstraints = Constraints([x > 5])\n\nresolve(x > 0, constraints)    # true\nresolve(x < 0, constraints)    # false  \nresolve(x > 10, constraints)   # x > 10 (as Num)","category":"page"},{"location":"manual/symbolics_interface/#Type-Handling","page":"Symbolics.jl Interface","title":"Type Handling","text":"","category":"section"},{"location":"manual/symbolics_interface/#Variable-Types","page":"Symbolics.jl Interface","title":"Variable Types","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The Symbolics.jl interface supports all standard variable types:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"# Real numbers (continuous)\n@variables position::Real velocity::Real\n\n# Integers (discrete)  \n@variables count::Integer index::Integer\n\n# Booleans (logical)\n@variables active::Bool valid::Bool","category":"page"},{"location":"manual/symbolics_interface/#Expression-Types","page":"Symbolics.jl Interface","title":"Expression Types","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"All expression types are automatically handled:","category":"page"},{"location":"manual/symbolics_interface/#Arithmetic-Expressions","page":"Symbolics.jl Interface","title":"Arithmetic Expressions","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real y::Real\n\nexpr1 = x + y\nexpr2 = 2*x - 3*y  \nexpr3 = x^2 + y^2\nexpr4 = -x + 5","category":"page"},{"location":"manual/symbolics_interface/#Comparison-Expressions","page":"Symbolics.jl Interface","title":"Comparison Expressions","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"comp1 = x > y\ncomp2 = x >= 0\ncomp3 = x == 5\ncomp4 = x <= 10\ncomp5 = x < y + 1","category":"page"},{"location":"manual/symbolics_interface/#Boolean-Expressions","page":"Symbolics.jl Interface","title":"Boolean Expressions","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables p::Bool q::Bool\n\nbool1 = p & q\nbool2 = p | q\nbool3 = !p\nbool4 = (p & q) | (!p & !q)","category":"page"},{"location":"manual/symbolics_interface/#Mixed-Expressions","page":"Symbolics.jl Interface","title":"Mixed Expressions","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real p::Bool\n\nmixed1 = (x > 0) & p\nmixed2 = p | (x < 5)\nmixed3 = p => (x >= 0)","category":"page"},{"location":"manual/symbolics_interface/#Conversion-Details","page":"Symbolics.jl Interface","title":"Conversion Details","text":"","category":"section"},{"location":"manual/symbolics_interface/#Automatic-Unwrapping","page":"Symbolics.jl Interface","title":"Automatic Unwrapping","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Num expressions are automatically unwrapped to SymbolicUtils.Symbolic:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"@variables x::Real\nnum_expr = x > 0                    # Symbolics.Num\nsymbolic_expr = unwrap(num_expr)    # SymbolicUtils.BasicSymbolic{Bool}","category":"page"},{"location":"manual/symbolics_interface/#Automatic-Wrapping","page":"Symbolics.jl Interface","title":"Automatic Wrapping","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Results are wrapped back to Num when appropriate:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"result = resolve(x > 10, constraints)\n# If cannot resolve: returns Num\n# If resolves to bool: returns Bool","category":"page"},{"location":"manual/symbolics_interface/#Type-Preservation","page":"Symbolics.jl Interface","title":"Type Preservation","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The interface preserves semantic meaning:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"# Input: Num expression\n# Processing: SymbolicUtils backend\n# Output: Appropriate type (Bool for constants, Num for expressions)","category":"page"},{"location":"manual/symbolics_interface/#Usage-Patterns","page":"Symbolics.jl Interface","title":"Usage Patterns","text":"","category":"section"},{"location":"manual/symbolics_interface/#Basic-Workflow","page":"Symbolics.jl Interface","title":"Basic Workflow","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"using Symbolics, SymbolicSMT\n\n# 1. Create variables\n@variables x::Real y::Real\n\n# 2. Define constraints  \nconstraints = Constraints([x >= 0, y >= 0])\n\n# 3. Query system\nresult1 = issatisfiable(x + y > 5, constraints)  \nresult2 = isprovable(x >= 0, constraints)\nresult3 = resolve(x > 10, constraints)","category":"page"},{"location":"manual/symbolics_interface/#Advanced-Usage","page":"Symbolics.jl Interface","title":"Advanced Usage","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"# Mixed variable types\n@variables pos::Real vel::Real gear::Integer active::Bool\n\n# Complex constraint set\nconstraints = Constraints([\n    pos >= 0,                           # Real constraint\n    vel >= 0, vel <= 120,              # Real bounds\n    gear >= 1, gear <= 5,              # Integer constraint\n    active,                             # Boolean constraint\n    active => (vel > 0),               # Conditional constraint\n    (gear > 3) => (vel > 50)          # Gear-speed relationship\n])\n\n# Complex queries\ncan_be_stationary = issatisfiable(vel == 0, constraints)\nalways_moving = isprovable(vel > 0, constraints)  \nhigh_gear_fast = isprovable((gear > 3) => (vel > 50), constraints)","category":"page"},{"location":"manual/symbolics_interface/#Comparison-with-SymbolicUtils-Interface","page":"Symbolics.jl Interface","title":"Comparison with SymbolicUtils Interface","text":"","category":"section"},{"location":"manual/symbolics_interface/#Symbolics.jl-Interface-(Recommended)","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface (Recommended)","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"using Symbolics, SymbolicSMT\n\n@variables x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nresult = issatisfiable(x + y > 1, constraints)","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Benefits:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Modern Julia ecosystem standard\nClean @variables syntax\nAutomatic type handling\nBetter integration with other packages","category":"page"},{"location":"manual/symbolics_interface/#SymbolicUtils.jl-Interface","page":"Symbolics.jl Interface","title":"SymbolicUtils.jl Interface","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"using SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real  \nconstraints = Constraints([x > 0, y > 0])\nresult = issatisfiable(x + y > 1, constraints)","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"When to use:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Advanced symbolic manipulation\nCustom symbolic operations\nLower-level control\nExisting SymbolicUtils.jl codebase","category":"page"},{"location":"manual/symbolics_interface/#Mixed-Usage","page":"Symbolics.jl Interface","title":"Mixed Usage","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Both interfaces can be used together:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"using Symbolics, SymbolicUtils, SymbolicSMT\n\n# Mix Symbolics and SymbolicUtils variables\n@variables x::Real          # Symbolics.Num\n@syms y::Real              # SymbolicUtils.Symbolic\n\n# Both work in the same constraint set\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)  # Works seamlessly","category":"page"},{"location":"manual/symbolics_interface/#Error-Handling","page":"Symbolics.jl Interface","title":"Error Handling","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The Symbolics.jl interface provides the same error handling as the SymbolicUtils backend:","category":"page"},{"location":"manual/symbolics_interface/#Conversion-Errors","page":"Symbolics.jl Interface","title":"Conversion Errors","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"# If expressions cannot be converted to Z3\ntry\n    constraints = Constraints([unsupported_expr])\ncatch e\n    # Detailed error message about conversion failure\n    println(e)\nend","category":"page"},{"location":"manual/symbolics_interface/#Type-Mismatches","page":"Symbolics.jl Interface","title":"Type Mismatches","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"# Type mismatches are caught during unwrapping\n@variables x::Real\n\n# This would cause an error if x is used in boolean context incorrectly\n# The error message will indicate the type mismatch","category":"page"},{"location":"manual/symbolics_interface/#Performance-Notes","page":"Symbolics.jl Interface","title":"Performance Notes","text":"","category":"section"},{"location":"manual/symbolics_interface/#Zero-Overhead-Design","page":"Symbolics.jl Interface","title":"Zero Overhead Design","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"The Symbolics.jl interface adds minimal overhead:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Dispatch cost: Single method lookup\nConversion cost: Simple unwrap/wrap operations  \nBackend unchanged: Same optimized SymbolicUtils processing","category":"page"},{"location":"manual/symbolics_interface/#Memory-Usage","page":"Symbolics.jl Interface","title":"Memory Usage","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Shared backend: No duplication of solver state\nMinimal wrappers: Num types are lightweight wrappers\nEfficient conversion: Direct delegation without copying","category":"page"},{"location":"manual/symbolics_interface/#Recommendations","page":"Symbolics.jl Interface","title":"Recommendations","text":"","category":"section"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"For best performance:","category":"page"},{"location":"manual/symbolics_interface/","page":"Symbolics.jl Interface","title":"Symbolics.jl Interface","text":"Batch constraint creation rather than creating many small sets\nUse appropriate variable types for your problem domain\nPrefer the Symbolics interface for new code (better ecosystem integration)\nMix interfaces judiciously - conversion has minimal but non-zero cost","category":"page"},{"location":"#SymbolicSMT.jl","page":"Home","title":"SymbolicSMT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Satisfiability solving for symbolic expressions","category":"page"},{"location":"","page":"Home","title":"Home","text":"SymbolicSMT.jl provides an interface between SymbolicUtils.jl and Symbolics.jl symbolic expressions and the Z3 satisfiability modulo theories (SMT) solver. This allows you to check satisfiability and provability of symbolic boolean expressions containing arithmetic constraints.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Symbolics.jl integration: Work with @variables and Num types from Symbolics.jl\nSymbolicUtils.jl support: Direct compatibility with SymbolicUtils expressions\nZ3 integration: Leverage the power of Microsoft Research's Z3 solver  \nMultiple theories: Support for linear and nonlinear real arithmetic\nSatisfiability checking: Determine if constraints have solutions\nProvability checking: Verify if statements are always true under constraints","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SymbolicSMT\")","category":"page"},{"location":"#Quick-Example-with-Symbolics.jl","page":"Home","title":"Quick Example with Symbolics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Symbolics, SymbolicSMT\n\n# Create symbolic variables with Symbolics.jl\n@variables x::Real y::Real\n\n# Define constraints: both variables are positive\nconstraints = Constraints([x > 0, y > 0])\n\n# Check satisfiability: Can x + y be greater than 1?\nissatisfiable(x + y > 1, constraints)  # true\n\n# Check provability: Is x + y always positive?\nisprovable(x + y > 0, constraints)     # true\n\n# Check provability: Is x always greater than y?\nisprovable(x > y, constraints)         # false\n\n# Resolve expressions to constants when possible\nresolve(x > 0, constraints)     # true (always true)\nresolve(x > 10, constraints)    # x > 10 (cannot determine)","category":"page"},{"location":"#Alternative:-SymbolicUtils.jl-Interface","page":"Home","title":"Alternative: SymbolicUtils.jl Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicSMT.jl also supports the lower-level SymbolicUtils.jl interface:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SymbolicUtils, SymbolicSMT\n\n@syms x::Real y::Real\nconstraints = Constraints([x > 0, y > 0])\nissatisfiable(x + y > 1, constraints)  # true","category":"page"},{"location":"#Package-Ecosystem","page":"Home","title":"Package Ecosystem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SymbolicSMT.jl is part of the JuliaSymbolics ecosystem and works seamlessly with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symbolics.jl: High-level symbolic computation and modeling\nSymbolicUtils.jl: Core symbolic expression manipulation\nModelingToolkit.jl: Symbolic-numeric modeling","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Z3.jl: Julia bindings for the Z3 theorem prover\nJuMP.jl: Mathematical optimization in Julia\nSatisfiability.jl: Alternative SAT/SMT interface","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation: Browse the manual and API reference in the sidebar\nExamples: Check out the tutorials for practical usage patterns\nIssues: Report bugs or request features on GitHub\nDiscussions: Join the community on the Julia Discourse","category":"page"}]
}
